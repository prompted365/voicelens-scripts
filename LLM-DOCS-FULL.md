# VoiceLens Scripts - Complete Documentation

**Generated**: 2025-10-14 16:34:27 UTC  
**Total Files**: 20  
**Purpose**: Complete documentation context for LLM consumption

> This file is automatically generated by concatenating all project markdown files.
> Do not edit directly - changes will be overwritten.

---


# Documentation File Tree

```
docs/
│   ├── DEPLOYMENT_OPERATIONS_GUIDE.md
│   ├── PROVIDER_INTEGRATION_GUIDE.md
│   ├── README.md
│   ├── VCP_SCHEMA_SPECIFICATION.md
│   ├── VCP_SYSTEM_OVERVIEW.md
reports/
│   ├── quality.md
.
├── ASSISTABLE_AI_INTEGRATION.md
├── CONTACT-US.md
├── CONTRIBUTING.md
├── DEPLOYMENT.md
├── HANDOVER_GUIDE.md
├── LOGISTICS.md
├── README.md
├── README_ENVIRONMENT.md
├── USAGE.md
├── VCP_GOVERNANCE_CHARTER.md
├── VCP_GOVERNANCE_EXECUTIVE_SUMMARY.md
├── VCP_IMPLEMENTATION_CONSISTENCY_FRAMEWORK.md
├── VCP_V0.5_CHANGELOG.md
├── VCP_WORKING_GROUPS_STRUCTURE.md
```

---


================================================================================
📄 FILE: docs/README.md
📝 TITLE: Voice Context Protocol (VCP) System - Complete Documentation
📊 SIZE: 16,721 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Voice Context Protocol (VCP) System - Complete Documentation

## Overview

The Voice Context Protocol (VCP) system is a comprehensive framework for normalizing, processing, and analyzing voice AI interactions across multiple providers. This documentation provides everything needed to understand, implement, and deploy VCP-compatible systems in any environment.

## Documentation Structure

This documentation is organized into several comprehensive guides that together provide complete coverage of the VCP system:

### 📚 Core Documentation

1. **[System Overview](docs/(./VCP_SYSTEM_OVERVIEW.md))** - High-level architecture, components, and features
2. **[Schema Specification](docs/(./VCP_SCHEMA_SPECIFICATION.md))** - Complete VCP v0.5 schema with validation rules
3. **[Provider Integration Guide](docs/(./PROVIDER_INTEGRATION_GUIDE.md))** - Webhook integration and mapping implementation
4. **[Deployment & Operations Guide](docs/(./DEPLOYMENT_OPERATIONS_GUIDE.md))** - Production deployment and monitoring

## Quick Start

### Understanding the VCP System

The VCP system consists of four main layers:

```
┌─────────────────────────────────────────────────────────────────┐
│                    VCP System Architecture                      │
├─────────────────────────────────────────────────────────────────┤
│  Provider Layer    │  Normalization    │  Analytics Engine     │
│  ┌─────────────────┐│  ┌─────────────────┐│  ┌─────────────────┐│
│  │ Retell AI       ││  │ VCP v0.5 Schema ││  │ Performance     ││
│  │ Bland AI        ││  │ Field Mapping   ││  │ Success Rates   ││
│  │ Vapi            ││  │ Transformation  ││  │ Cost Analysis   ││
│  │ ElevenLabs      ││  │ Validation      ││  │ Business Impact ││
│  │ OpenAI Realtime ││  │                 ││  │                 ││
│  │ Assistable AI   ││  │                 ││  │                 ││
│  └─────────────────┘│  └─────────────────┘│  └─────────────────┘│
├─────────────────────────────────────────────────────────────────┤
│            Monitoring & Alerting           │  Web Dashboard    │
│                                            │                   │
└─────────────────────────────────────────────────────────────────┘
```
### Key Features

- **Universal Schema**: VCP v0.5 provides comprehensive, version-compatible normalization
- **6+ Provider Support**: Pre-built integrations with major voice AI providers
- **Real-time Processing**: Millisecond webhook transformation and validation
- **Business Intelligence**: Advanced analytics with Assistable AI extractions
- **Monitoring**: Automated provider health checks and change detection
- **Developer-Friendly**: Complete REST API, interactive dashboard, extensive docs

## Implementation Guide

### 1. Choose Your Implementation Approach

#### Python Implementation (Reference)
The reference implementation is in Python with Flask:

```python
# From voicelens_ops_app.py
from provider_documentation import VoiceAIProviderRegistry, VCPMapper
from vcp_v05_schema import VCPMessage, VCPValidator

# Initialize system
registry = VoiceAIProviderRegistry()
mapper = VCPMapper(registry)
validator = VCPValidator()

@app.route('/webhook/<provider>', methods=['POST'])
def handle_webhook(provider: str):
    # Transform provider webhook to VCP
    vcp_message = mapper.map_to_vcp(provider, request.json)
    
    # Validate VCP schema
    validation = validator.validate_v05(vcp_message)
    
    # Process and store
    return jsonify({'success': True, 'validation': validation})
```
#### TypeScript/Node.js Implementation

```typescript
interface VCPMessage {
  vcp_version: "0.5";
  vcp_payload: VCPPayload;
  audit: Audit;
}

class VCPSystem {
  async processWebhook(provider: string, payload: any): Promise<VCPMessage> {
    // 1. Transform to VCP
    const vcpMessage = await this.mapper.mapToVCP(provider, payload);
    
    // 2. Validate
    const validation = this.validator.validate(vcpMessage);
    
    // 3. Store and analyze
    await this.store(vcpMessage);
    
    return vcpMessage;
  }
}
```
### 2. Core Components to Implement

#### A. VCP Schema (Required)
Implement the VCP v0.5 schema in your target language:

**Core Models:**
- `VCPMessage` (root container)
- `Call` (call information with channel/direction support)
- `ModelSelection` (AI model attribution)
- `Outcomes` (objective and perceived results)
- `HumanReadableContext` (summary for humans)
- `Artifacts` (references to recordings/transcripts)
- `Custom` (provider-specific data)
- `ConsentRecord` (consent tracking)
- `Provenance` (data lineage)
- `Audit` (processing metadata)

#### B. Provider Registry (Required)
Implement provider information management:

```python
# Provider configuration structure
@dataclass
class ProviderInfo:
    name: str
    company: str
    website: str
    docs_url: str
    api_base_url: str
    webhook_auth: WebhookAuthConfig
    supported_events: List[WebhookEventType]
    webhook_schemas: List[WebhookSchema]
    vcp_mapping_rules: Dict[str, str]  # provider_path -> vcp_path
```
#### C. VCP Mapping Engine (Required)
Core transformation logic:

```python
class VCPMapper:
    def map_to_vcp(self, provider_name: str, webhook_payload: dict) -> dict:
        # 1. Load provider configuration
        # 2. Apply field mappings
        # 3. Handle provider-specific transformations
        # 4. Build complete VCP structure with defaults
        # 5. Return validated VCP message
```
#### D. Validation System (Required)
Schema validation and business rules:

```python
class VCPValidator:
    def validate_v05(self, message: VCPMessage) -> Dict[str, List[str]]:
        # 1. Schema validation (pydantic/joi/etc.)
        # 2. Business logic validation
        # 3. Cross-field validation
        # 4. Return errors and warnings
```
### 3. Supported Providers

The system includes pre-built integrations for:

| Provider | Complexity | Key Features |
|----------|------------|--------------|
| **Retell AI** | Medium | Signature validation, direction mapping |
| **Vapi** | Medium | End-of-call reports, status conversion |
| **Assistable AI** | Advanced | AI extractions, business intelligence |
| **Bland AI** | Simple | Bearer token auth, basic mapping |
| **ElevenLabs** | Medium | HMAC validation, IP whitelisting |
| **OpenAI Realtime** | Medium | Real-time events, session tracking |

### 4. Channel & Direction Support

VCP v0.5 introduces comprehensive directional support:

```python
# Preferred approach
call = {
    "channel": "phone",      # Communication medium
    "direction": "inbound",  # Call direction
    "from_": "+1234567890",
    "to": "+1987654321"
}

# Legacy support (backward compatible)
call = {
    "channel": "inbound"  # Combined channel+direction
}
```
### 5. Provider-Specific Transformations

Each provider requires specific data transformations:

#### Vapi Status Mapping
```python
def convert_vapi_status(ended_reason: str) -> str:
    mapping = {
        "hangup": "success",           # Normal completion
        "timeout": "timeout",
        "error": "error",
        "completed": "success"
    }
    return mapping.get(ended_reason.lower(), "unknown")
```
#### Assistable AI Business Intelligence
```python
# Automatic extraction to business intelligence
extractions = {
    "customer_interest_level": "high",
    "budget_range": "$500-1000",
    "decision_maker": True,
    "purchase_timeline": "within_30_days"
}

# Automatically mapped to CRM/Sales systems
integrations = {
    "crm_system": {...},
    "sales_system": {...}
}
```
## Architecture Patterns

### Data Flow Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Raw Webhook   │───▶│   VCP Mapper    │───▶│  Validated VCP  │
│                 │    │                 │    │                 │
│ Provider Format │    │ • Field Mapping │    │ • Schema v0.5   │
│ • Retell        │    │ • Type Convert  │    │ • Validation    │
│ • Vapi          │    │ • Status Trans  │    │ • Enrichment    │
│ • Assistable    │    │ • Direction     │    │ • Provenance    │
│ • Bland         │    │ • Sentiment     │    │ • Audit Trail   │
│ • ElevenLabs    │    │ • Extractions   │    │                 │
│ • OpenAI        │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Storage &     │    │    Analytics    │    │   Monitoring    │
│   Archival      │    │    Engine       │    │   & Alerting    │
│                 │    │                 │    │                 │
│ • JSON Storage  │    │ • Performance   │    │ • Validation    │
│ • Searchable    │    │ • Success Rate  │    │ • Failures      │
│ • Timestamped   │    │ • Cost Analysis │    │ • Trends        │
│ • Compressed    │    │ • Business KPI  │    │ • Health Checks │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```
### Database Design

```sql
-- Core VCP storage
CREATE TABLE vcp_messages (
    id UUID PRIMARY KEY,
    call_id VARCHAR(255) NOT NULL,
    provider VARCHAR(50) NOT NULL,
    vcp_version VARCHAR(10) NOT NULL DEFAULT '0.5',
    raw_payload JSONB NOT NULL,
    
    -- Extracted fields for fast querying
    start_time TIMESTAMP WITH TIME ZONE,
    end_time TIMESTAMP WITH TIME ZONE,
    duration_sec INTEGER,
    channel VARCHAR(20),
    direction VARCHAR(10),
    status VARCHAR(20),
    user_satisfaction_score DECIMAL(3,2),
    cost_usd DECIMAL(10,4),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```
## Development Workflow

### 1. Setup Development Environment

```bash
# Clone reference implementation
git clone https://github.com/prompted365/voicelens-scripts.git
cd voicelens-scripts

# Install dependencies
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# Run development server
python voicelens_ops_app.py
```
### 2. Test Provider Integrations

```bash
# Test webhook transformation
curl -X POST http://localhost:8080/api/webhook-test \
  -H "Content-Type: application/json" \
  -d '{
    "provider": "retell",
    "payload": {
      "event": "call_ended",
      "call": {
        "call_id": "test_123",
        "direction": "inbound"
      }
    }
  }'
```
### 3. Validate VCP Output

Check that your implementation produces valid VCP v0.5 messages:

```python
from vcp_v05_schema import VCPValidator

validator = VCPValidator()
result = validator.validate_v05(your_vcp_message)

print("Validation:", result)
# Should show: {"errors": [], "warnings": []}
```
## Production Deployment

### Docker Deployment

```bash
# Build and run with Docker Compose
docker-compose up -d

# Health check
curl http://localhost:8080/health
```
### Kubernetes Deployment

```bash
# Deploy to Kubernetes
kubectl apply -f k8s/

# Check status
kubectl get pods -n voicelens
```
### Environment Configuration

Key environment variables:

```bash
# Core configuration
SERVICE_HOST=0.0.0.0
SERVICE_PORT=8080
DATABASE_URL=postgresql://...

# Provider API keys
RETELL_API_KEY=your_key
VAPI_API_KEY=your_key
ASSISTABLE_API_KEY=your_key

# Webhook secrets
WEBHOOK_SECRET_RETELL=your_secret
WEBHOOK_SECRET_ELEVENLABS=your_secret

# Monitoring
MONITORING_ENABLED=true
CRON_SCHEDULE="0 */6 * * *"
```
## Advanced Features

### Business Intelligence Integration

The system automatically extracts business intelligence from Assistable AI calls:

```python
# Automatic mapping from AI extractions
webhook_data = {
    "extractions": {
        "customer_interest_level": "high",
        "budget_range": "$500-1000",
        "decision_maker": True,
        "purchase_timeline": "within_30_days"
    }
}

# Automatically becomes VCP business intelligence
vcp_integrations = {
    "crm_system": {
        "provider": "assistable_extractions",
        "lead_score": "high"
    },
    "sales_system": {
        "qualification_score": 0.85,
        "opportunity_data": {...}
    }
}
```
### Monitoring & Alerting

Automated monitoring system:

```python
# From monitor_provider_changes.py
class VoiceLensMonitoringSystem:
    async def run_monitoring_cycle(self):
        # 1. Check provider health
        # 2. Monitor documentation changes
        # 3. Check RSS feeds
        # 4. Store results and send alerts
```
### Analytics Dashboard

Real-time analytics with:
- Provider performance comparison
- Success rate tracking
- Cost analysis
- Business impact metrics
- Webhook testing interface

## Security Considerations

### Webhook Security

1. **IP Whitelisting**: Restrict webhook endpoints to known provider IPs
2. **Signature Validation**: Verify webhook signatures (HMAC, etc.)
3. **Rate Limiting**: Implement rate limiting for all endpoints
4. **Input Validation**: Validate all webhook payloads
5. **HTTPS Only**: Use TLS encryption for all communications

### Data Privacy

1. **Consent Tracking**: Built-in consent management
2. **Data Retention**: Configurable retention policies
3. **Anonymization**: Caller ID hashing and PII protection
4. **Compliance**: GDPR, CCPA compliance flags

## Performance Optimization

### Database Optimization

- Efficient indexing on frequently queried fields
- JSONB storage for flexible provider data
- Automated analytics aggregation
- Connection pooling

### Application Performance

- Redis caching for provider configurations
- Async webhook processing
- Connection pooling
- Rate limiting and request throttling

## Support & Community

### Getting Help

1. **Documentation**: Start with the comprehensive guides in this repository
2. **Examples**: Check the baseline examples and test data
3. **Code**: Review the reference implementation
4. **Issues**: Report bugs or request features via GitHub issues

### Contributing

The VCP system is designed to be extensible:

1. **New Providers**: Add provider configurations to the registry
2. **Schema Extensions**: Propose v0.6+ schema enhancements
3. **Language Implementations**: Create VCP implementations in other languages
4. **Integrations**: Build additional analytics or monitoring integrations

## Roadmap

### Current Version: v0.5
- ✅ Comprehensive schema with channel/direction support
- ✅ 6+ provider integrations
- ✅ Business intelligence extraction
- ✅ Monitoring and alerting
- ✅ Analytics dashboard

### Future Versions
- **v0.6**: Enhanced real-time processing
- **v0.7**: Machine learning integration
- **v0.8**: Advanced business intelligence
- **v1.0**: Enterprise features and governance

## License

This documentation and reference implementation are provided under the MIT License. See LICENSE file for details.

---

**Next Steps:** Choose the documentation section most relevant to your needs:
- **New to VCP?** Start with [System Overview](docs/(./VCP_SYSTEM_OVERVIEW.md))
- **Implementing VCP?** See [Schema Specification](docs/(./VCP_SCHEMA_SPECIFICATION.md))
- **Adding Providers?** Check [Provider Integration Guide](docs/(./PROVIDER_INTEGRATION_GUIDE.md))
- **Deploying to Production?** Review [Deployment & Operations Guide](docs/(./DEPLOYMENT_OPERATIONS_GUIDE.md))



================================================================================
📄 FILE: docs/VCP_SYSTEM_OVERVIEW.md
📝 TITLE: Voice Context Protocol (VCP) System Documentation
📊 SIZE: 25,309 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Voice Context Protocol (VCP) System Documentation

## Table of Contents
1. [System Overview](#system-overview)
2. [VCP Protocol Specification](#vcp-protocol-specification)
3. [Normalization & Mapping Architecture](#normalization--mapping-architecture)
4. [Provider Integration System](#provider-integration-system)
5. [Implementation Guide](#implementation-guide)
6. [Deployment & Operations](#deployment--operations)

## System Overview

The Voice Context Protocol (VCP) system is a comprehensive framework for normalizing, processing, and analyzing voice AI interactions across multiple providers. It provides a unified schema, mapping engine, monitoring capabilities, and analytics platform.

### Core Components

```
┌─────────────────────────────────────────────────────────────────┐
│                    VCP System Architecture                      │
├─────────────────────────────────────────────────────────────────┤
│  Provider Webhooks  │  VCP Normalization  │  Analytics Engine  │
│  ┌─────────────────┐│  ┌─────────────────┐│  ┌─────────────────┐│
│  │ Retell AI       ││  │ Schema v0.5     ││  │ Performance     ││
│  │ Bland AI        ││  │ Validation      ││  │ Success Rates   ││
│  │ Vapi            ││  │ Transformation  ││  │ Cost Analysis   ││
│  │ ElevenLabs      ││  │ Standardization ││  │ Business Impact ││
│  │ OpenAI Realtime ││  │                 ││  │                 ││
│  │ Assistable AI   ││  │                 ││  │                 ││
│  └─────────────────┘│  └─────────────────┘│  └─────────────────┘│
├─────────────────────────────────────────────────────────────────┤
│            Monitoring & Alerting           │  Web Dashboard    │
│  ┌─────────────────────────────────────────┐│  ┌─────────────────┐│
│  │ Provider Health Checks                  ││  │ Real-time Stats ││
│  │ Documentation Changes                   ││  │ Provider Cards  ││
│  │ RSS Feed Monitoring                     ││  │ Webhook Testing ││
│  │ Endpoint Status Tracking                ││  │ Analytics Viz   ││
│  └─────────────────────────────────────────┘│  └─────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```
### Key Features

- **Universal Schema**: VCP v0.5 provides a comprehensive, version-compatible schema for all voice AI interactions
- **Provider Agnostic**: Supports 6+ major voice AI providers with extensible architecture
- **Real-time Processing**: Handles webhook transformations in milliseconds
- **Comprehensive Analytics**: Business impact metrics, performance tracking, and cost analysis
- **Automated Monitoring**: Provider health checks, documentation change detection, and alerting
- **Developer-Friendly**: Full REST API, interactive dashboard, and extensive documentation

## VCP Protocol Specification

### Schema Evolution

The Voice Context Protocol has evolved through multiple versions to provide comprehensive coverage of voice AI interactions:

- **v0.3**: Foundation schema with basic call information and outcomes
- **v0.4**: Added provenance, consent tracking, and enhanced business metrics
- **v0.5**: Current version with full channel direction support, comprehensive model attribution, and business impact tracking

### VCP v0.5 Schema Structure

```python
# Core Schema Components from vcp_v05_schema.py

class VCPMessage(BaseModel):
    """Complete VCP v0.5 message structure"""
    vcp_version: VCPVersion = Field(VCPVersion.V05, description="VCP schema version")
    vcp_payload: VCPPayload = Field(..., description="Main VCP payload")
    audit: Audit = Field(..., description="Audit information")

class VCPPayload(BaseModel):
    """The main VCP payload structure"""
    call: Call                              # Enhanced call information
    model_selection: ModelSelection         # AI model selection details
    outcomes: Outcomes                      # Call outcomes and assessments
    hcr: HumanReadableContext              # Human-readable summary
    artifacts: Artifacts                    # Recording and transcript references
    custom: Custom                          # Provider-specific data
    consent: Optional[ConsentRecord]        # User consent tracking
    provenance: Provenance                  # Data lineage information
```
### Channel & Direction Support

VCP v0.5 introduces comprehensive support for call directionality:

```python
class ChannelType(str, Enum):
    """Communication channel types"""
    PHONE = "phone"
    WEB = "web"
    MOBILE = "mobile"
    EMBED = "embed"
    API = "api"
    WEBSOCKET = "websocket"
    # Directional channels (for backward compatibility)
    INBOUND = "inbound"
    OUTBOUND = "outbound"

class CallDirection(str, Enum):
    """Call direction types (preferred approach for v0.5+)"""
    INBOUND = "inbound"
    OUTBOUND = "outbound"

class Call(BaseModel):
    """Enhanced call information with v0.5 extensions"""
    # Core fields
    call_id: str
    session_id: str
    provider: str
    start_time: datetime
    end_time: Optional[datetime]
    duration_sec: Optional[int]
    
    # v0.5 Extensions
    channel: Optional[ChannelType]          # Communication medium
    direction: Optional[CallDirection]       # Call direction
    from_: Optional[str]                    # Originating identifier
    to: Optional[str]                       # Destination identifier
    capabilities_invoked: List[Union[str, CapabilityInvocation]]
```
### Outcome Status Support

The system supports comprehensive outcome tracking:

```python
class OutcomeStatus(str, Enum):
    """Call outcome status"""
    SUCCESS = "success"
    FAILURE = "failure"
    PARTIAL = "partial"
    TIMEOUT = "timeout"
    ERROR = "error"
    UNKNOWN = "unknown"    # Added in latest version
```
## Normalization & Mapping Architecture

### VCP Mapping Engine

The core normalization system is implemented in `provider_documentation.py` with the `VCPMapper` class:

```python
class VCPMapper:
    """Maps provider webhooks to VCP v0.5 format"""
    
    def map_to_vcp(self, provider_name: str, webhook_payload: Dict[str, Any]) -> Dict[str, Any]:
        """Main transformation method"""
        # 1. Load provider mapping rules
        provider = self.registry.get_provider(provider_name)
        
        # 2. Apply field mappings
        for provider_path, vcp_path in provider.vcp_mapping_rules.items():
            value = self._get_nested_value(webhook_payload, provider_path)
            if value is not None:
                # 3. Apply provider-specific transformations
                transformed_value = self._apply_provider_transformations(
                    provider_name, provider_path, value, vcp_path
                )
                self._set_nested_value(vcp_data, vcp_path, transformed_value)
        
        # 4. Build complete VCP structure with defaults
        return self._build_vcp_structure(provider_name, vcp_data, webhook_payload)
```
### Provider-Specific Transformations

Each provider requires specific data transformations:

#### Retell AI Mapping
```python
# From provider_documentation.py - Retell configuration
"retell": ProviderInfo(
    name="Retell AI",
    vcp_mapping_rules={
        "call.call_id": "call.call_id",
        "call.from_number": "call.from_",
        "call.to_number": "call.to",
        "call.direction": "call.direction",      # Maps to direction field
        "call.start_timestamp": "call.start_time",
        "call.end_timestamp": "call.end_time",
        "call.transcript": "artifacts.transcript",
    }
)
```
#### Vapi Mapping with Status Conversion
```python
# Vapi requires endedReason to VCP status conversion
"vapi": ProviderInfo(
    name="Vapi",
    vcp_mapping_rules={
        "message.call.id": "call.call_id",
        "message.endedReason": "outcomes.objective.status",  # Requires conversion
        "message.artifact.transcript": "artifacts.transcript",
    }
)

def _convert_vapi_ended_reason_to_status(self, ended_reason: str) -> str:
    """Convert Vapi endedReason to VCP outcome status"""
    reason = ended_reason.lower()
    
    if reason in ["completed", "success", "assistant_ended"]:
        return "success"
    elif reason in ["hangup", "user_hangup", "customer_hangup"]:
        return "success"  # Normal hangup is successful completion
    elif reason in ["timeout", "no_answer", "voicemail", "busy"]:
        return "timeout"
    elif reason in ["error", "failed", "connection_error", "technical_error"]:
        return "error"
    elif reason in ["transferred", "forwarded"]:
        return "partial"
    else:
        return "unknown"
```
#### Assistable AI Advanced Mapping
```python
# Assistable AI has the most complex mapping with extractions
"assistable": ProviderInfo(
    vcp_mapping_rules={
        "call_id": "call.call_id",
        "direction": "call.direction",
        "to": "call.to",
        "from": "call.from_",
        "user_sentiment": "outcomes.user_satisfaction_score",
        "extractions": "custom.provider_specific.assistable.extractions",
        "call_completion": "outcomes.objective.metrics.task_completion",
    }
)

def _convert_sentiment_to_score(self, sentiment: str) -> float:
    """Convert Assistable.ai sentiment string to numerical score"""
    sentiment_mapping = {
        "very_positive": 1.0,
        "positive": 0.8,
        "slightly_positive": 0.6,
        "neutral": 0.5,
        "slightly_negative": 0.4,
        "negative": 0.2,
        "very_negative": 0.0
    }
    return sentiment_mapping.get(sentiment.lower(), 0.5)
```
### Data Flow Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Raw Webhook   │───▶│   VCP Mapper    │───▶│  Validated VCP  │
│                 │    │                 │    │                 │
│ Provider Format │    │ • Field Mapping │    │ • Schema v0.5   │
│ • Retell        │    │ • Type Convert  │    │ • Validation    │
│ • Vapi          │    │ • Status Trans  │    │ • Enrichment    │
│ • Assistable    │    │ • Direction     │    │ • Provenance    │
│ • Bland         │    │ • Sentiment     │    │ • Audit Trail   │
│ • ElevenLabs    │    │ • Extractions   │    │                 │
│ • OpenAI        │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Storage &     │    │    Analytics    │    │   Monitoring    │
│   Archival      │    │    Engine       │    │   & Alerting    │
│                 │    │                 │    │                 │
│ • JSON Storage  │    │ • Performance   │    │ • Validation    │
│ • Searchable    │    │ • Success Rate  │    │ • Failures      │
│ • Timestamped   │    │ • Cost Analysis │    │ • Trends        │
│ • Compressed    │    │ • Business KPI  │    │ • Health Checks │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```
## Provider Integration System

### Supported Providers

The system currently supports 6 major voice AI providers, each with comprehensive webhook schemas and mapping rules:

#### 1. Retell AI
```python
# Webhook Schema
webhook_schemas=[
    WebhookSchema(
        event_type=WebhookEventType.CALL_ENDED,
        required_fields=[
            "event", "call.call_id", "call.from_number", 
            "call.to_number", "call.direction", "call.start_timestamp",
            "call.end_timestamp", "call.disconnection_reason"
        ],
        optional_fields=[
            "call.transcript", "call.transcript_object", 
            "call.metadata", "call.call_analysis"
        ]
    )
]

# Authentication
webhook_auth=WebhookAuthConfig(
    method=AuthMethod.SIGNATURE_HEADER,
    header_name="x-retell-signature",
    secret_key_required=True,
    ip_addresses=["100.20.5.228"]
)
```
#### 2. Assistable AI (Advanced Integration)
```python
# Complex webhook with extractions and business intelligence
webhook_schemas=[
    WebhookSchema(
        event_type=WebhookEventType.CALL_ENDED,
        required_fields=[
            "call_id", "call_type", "direction", "to", "from",
            "disconnection_reason", "call_completion", "assistant_task_completion"
        ],
        optional_fields=[
            "user_sentiment", "call_summary", "recording_url", "full_transcript",
            "extractions"  # AI-extracted business data
        ],
        nested_objects={
            "extractions": []  # Completely dynamic - AI-extracted data
        }
    )
]

# Example extracted business intelligence
example_extractions = {
    "contact_zip_code": "90210",
    "customer_interest_level": "high",
    "next_followup_date": "2025-10-21",
    "product_interest": "premium_package",
    "budget_range": "$500-1000",
    "decision_maker": True,
    "purchase_timeline": "within_30_days"
}
```
### Provider Registry Architecture

```python
class VoiceAIProviderRegistry:
    """Central registry for voice AI provider information"""
    
    def __init__(self):
        self.providers = self._initialize_providers()
    
    def get_provider(self, provider_name: str) -> Optional[ProviderInfo]:
        """Get provider information by name"""
        return self.providers.get(provider_name.lower())
    
    def get_providers_by_event(self, event_type: WebhookEventType) -> List[ProviderInfo]:
        """Get providers that support a specific event type"""
        return [
            provider for provider in self.providers.values()
            if provider.supported_events and event_type in provider.supported_events
        ]
```
## Implementation Guide

### Core Implementation Steps

#### 1. VCP Schema Implementation

Start by implementing the VCP v0.5 schema in your target language. The Python reference implementation is in `vcp_v05_schema.py`:

```python
# Required models for any implementation
- VCPMessage (root)
- VCPPayload (main content)
- Call (call information)
- ModelSelection (AI model details)
- Outcomes (call results)
- HumanReadableContext (summary)
- Artifacts (references)
- Custom (provider-specific)
- ConsentRecord (consent tracking)
- Provenance (data lineage)
- Audit (processing info)
```
For TypeScript/React implementation:

```typescript
// TypeScript equivalent interfaces
interface VCPMessage {
  vcp_version: "0.5";
  vcp_payload: VCPPayload;
  audit: Audit;
}

interface Call {
  call_id: string;
  session_id: string;
  provider: string;
  start_time: string;  // ISO datetime
  end_time?: string;
  duration_sec?: number;
  channel?: ChannelType;
  direction?: CallDirection;
  from_?: string;
  to?: string;
  capabilities_invoked: (string | CapabilityInvocation)[];
}

type ChannelType = "phone" | "web" | "mobile" | "embed" | "api" | "websocket" | "inbound" | "outbound";
type CallDirection = "inbound" | "outbound";
type OutcomeStatus = "success" | "failure" | "partial" | "timeout" | "error" | "unknown";
```
#### 2. Provider Integration Layer

Implement a provider registry and mapping system:

```typescript
// TypeScript implementation approach
class ProviderRegistry {
  private providers: Map<string, ProviderInfo> = new Map();
  
  constructor() {
    this.initializeProviders();
  }
  
  private initializeProviders() {
    // Add provider configurations
    this.providers.set("retell", {
      name: "Retell AI",
      vcp_mapping_rules: {
        "call.call_id": "call.call_id",
        "call.direction": "call.direction",
        // ... mapping rules
      }
    });
  }
}

class VCPMapper {
  constructor(private registry: ProviderRegistry) {}
  
  async mapToVCP(providerName: string, webhookPayload: any): Promise<VCPMessage> {
    const provider = this.registry.getProvider(providerName);
    if (!provider) throw new Error(`Unknown provider: ${providerName}`);
    
    // Apply mapping rules
    const vcpData = this.applyMappingRules(provider, webhookPayload);
    
    // Build complete VCP structure
    return this.buildVCPMessage(providerName, vcpData, webhookPayload);
  }
}
```
#### 3. Webhook Processing Pipeline

```typescript
// Express.js/Node.js implementation example
import express from 'express';
import { VCPMapper } from './vcp-mapper';
import { validateVCPMessage } from './vcp-validator';

const app = express();
const mapper = new VCPMapper(new ProviderRegistry());

app.post('/webhook/:provider', async (req, res) => {
  const { provider } = req.params;
  const webhookPayload = req.body;
  
  try {
    // 1. Transform to VCP
    const vcpMessage = await mapper.mapToVCP(provider, webhookPayload);
    
    // 2. Validate schema
    const validation = validateVCPMessage(vcpMessage);
    if (validation.errors.length > 0) {
      return res.status(400).json({ 
        success: false, 
        errors: validation.errors 
      });
    }
    
    // 3. Store and process
    await this.storeVCPMessage(vcpMessage);
    await this.processAnalytics(vcpMessage);
    
    res.json({ 
      success: true, 
      transformation_time_ms: Date.now() - startTime 
    });
    
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});
```
#### 4. Analytics and Monitoring

Implement analytics processing for business insights:

```typescript
class AnalyticsEngine {
  async processVCPMessage(message: VCPMessage) {
    // Extract key metrics
    const metrics = {
      provider: message.vcp_payload.call.provider,
      duration_sec: message.vcp_payload.call.duration_sec,
      status: message.vcp_payload.outcomes.objective.status,
      cost_usd: this.extractCost(message),
      satisfaction_score: message.vcp_payload.outcomes.user_satisfaction_score,
      capabilities_used: message.vcp_payload.call.capabilities_invoked.length
    };
    
    // Update aggregated stats
    await this.updateProviderStats(metrics);
    await this.updateBusinessMetrics(metrics);
    await this.checkAlertConditions(metrics);
  }
  
  private extractCost(message: VCPMessage): number {
    // Extract cost from model attribution or custom data
    return message.vcp_payload.outcomes.model_outcome_attribution.total_cost_usd || 0;
  }
}
```
### Database Schema Recommendations

For storing VCP messages and analytics:

```sql
-- VCP Messages Table
CREATE TABLE vcp_messages (
    id UUID PRIMARY KEY,
    call_id VARCHAR(255) NOT NULL,
    provider VARCHAR(50) NOT NULL,
    vcp_version VARCHAR(10) NOT NULL,
    raw_payload JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Indexed fields for fast querying
    start_time TIMESTAMP WITH TIME ZONE,
    end_time TIMESTAMP WITH TIME ZONE,
    duration_sec INTEGER,
    channel VARCHAR(20),
    direction VARCHAR(10),
    status VARCHAR(20),
    
    INDEX idx_provider_created (provider, created_at),
    INDEX idx_call_id (call_id),
    INDEX idx_status (status),
    INDEX idx_timerange (start_time, end_time)
);

-- Analytics Aggregations
CREATE TABLE provider_analytics (
    id UUID PRIMARY KEY,
    provider VARCHAR(50) NOT NULL,
    date DATE NOT NULL,
    total_calls INTEGER DEFAULT 0,
    successful_calls INTEGER DEFAULT 0,
    failed_calls INTEGER DEFAULT 0,
    avg_duration_sec DECIMAL(10,2),
    total_cost_usd DECIMAL(10,2),
    avg_satisfaction_score DECIMAL(3,2),
    
    UNIQUE(provider, date)
);
```
## Deployment & Operations

### Environment Configuration

The system supports multiple deployment modes via environment variables:

```bash
# Core Service Configuration
SERVICE_HOST=0.0.0.0
SERVICE_PORT=8080

# Provider API Keys (stored securely)
RETELL_API_KEY=your_retell_key
VAPI_API_KEY=your_vapi_key
ASSISTABLE_API_KEY=your_assistable_key

# Database Configuration
DATABASE_URL=postgresql://user:pass@localhost:5432/voicelens
REDIS_URL=redis://localhost:6379

# Monitoring Configuration
MONITORING_ENABLED=true
CRON_SCHEDULE="0 */6 * * *"  # Every 6 hours

# Webhook Security
WEBHOOK_SECRET_RETELL=your_retell_webhook_secret
WEBHOOK_SECRET_ELEVENLABS=your_elevenlabs_webhook_secret
```
### Docker Deployment

```dockerfile
# Production Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Set up monitoring cron
RUN chmod +x scripts/setup_monitoring_cron.sh
RUN ./scripts/setup_monitoring_cron.sh

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# Run application
EXPOSE 8080
CMD ["python", "voicelens_ops_app.py"]
```
### Monitoring and Alerting

The system includes comprehensive monitoring capabilities:

```python
# From monitor_provider_changes.py
class VoiceLensMonitoringSystem:
    """Automated monitoring system for provider changes"""
    
    async def run_monitoring_cycle(self):
        """Complete monitoring cycle"""
        changes = []
        
        # 1. Check provider health
        health_changes = await self.check_provider_health()
        changes.extend(health_changes)
        
        # 2. Monitor documentation
        doc_changes = await self.monitor_documentation_changes()
        changes.extend(doc_changes)
        
        # 3. Check RSS feeds
        feed_changes = await self.check_rss_feeds()
        changes.extend(feed_changes)
        
        # 4. Store results
        if changes:
            await self.store_changes(changes)
            await self.send_alerts(changes)
        
        return changes
```
### Performance Optimization

Key performance considerations for large-scale deployment:

#### 1. Webhook Processing
- Implement async processing for webhook transformations
- Use connection pooling for database operations
- Cache provider configurations in memory
- Implement request rate limiting

#### 2. Analytics Performance
- Use time-series databases for metrics storage
- Pre-aggregate common analytics queries
- Implement efficient indexing strategies
- Use caching for frequently accessed data

#### 3. Monitoring Efficiency
- Batch provider health checks
- Use differential monitoring (only check changed content)
- Implement exponential backoff for failed requests
- Cache provider documentation locally

### Scaling Considerations

For high-volume deployments:

```yaml
# Kubernetes deployment example
apiVersion: apps/v1
kind: Deployment
metadata:
  name: voicelens-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: voicelens-api
  template:
    spec:
      containers:
      - name: api
        image: voicelens/api:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: voicelens-secrets
              key: database-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: voicelens-service
spec:
  selector:
    app: voicelens-api
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```
This comprehensive documentation provides everything needed to understand, implement, and deploy the VCP system in any environment. The modular architecture, detailed implementation guides, and extensive code examples enable development teams to build compatible systems in their preferred technology stack.



================================================================================
📄 FILE: docs/VCP_SCHEMA_SPECIFICATION.md
📝 TITLE: VCP Schema v0.5 - Complete Specification
📊 SIZE: 24,347 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VCP Schema v0.5 - Complete Specification

## Overview

The Voice Context Protocol (VCP) v0.5 is a comprehensive schema for standardizing voice AI interactions across providers. This document provides the complete specification, implementation details, and validation rules.

## Schema Architecture

### Core Message Structure

Every VCP message follows this root structure:

```python
# From vcp_v05_schema.py
class VCPMessage(BaseModel):
    """Complete VCP v0.5 message structure"""
    vcp_version: VCPVersion = Field(VCPVersion.V05, description="VCP schema version")
    vcp_payload: VCPPayload = Field(..., description="Main VCP payload")
    audit: Audit = Field(..., description="Audit information")
```
### Version Support and Compatibility

VCP supports multiple versions with backward compatibility:

```python
class VCPVersion(str, Enum):
    """Supported VCP versions"""
    V03 = "0.3"  # Foundation version
    V04 = "0.4"  # Added provenance and consent
    V05 = "0.5"  # Current version with full feature set
```
**Version Compatibility Matrix:**

| Feature | v0.3 | v0.4 | v0.5 |
|---------|------|------|------|
| Basic Call Info | ✅ | ✅ | ✅ |
| Outcomes & HCR | ✅ | ✅ | ✅ |
| Provenance | ❌ | ✅ | ✅ |
| Consent Tracking | ❌ | ✅ | ✅ |
| Channel Direction | ❌ | Limited | ✅ |
| Model Attribution | ❌ | Basic | ✅ |
| Business Impact | ❌ | ❌ | ✅ |

## Detailed Field Specifications

### 1. Call Information (`call`)

The call object contains comprehensive information about the voice interaction:

```python
class Call(BaseModel):
    """Enhanced call information from v0.3 with v0.5 extensions"""
    # Required Core Fields
    call_id: str = Field(..., description="Unique identifier for the call")
    session_id: str = Field(..., description="Session identifier for grouping related calls")
    provider: str = Field(..., description="Voice AI provider (e.g., 'openai', 'retell', 'bland')")
    start_time: datetime = Field(..., description="Call start timestamp")
    
    # Optional Core Fields
    end_time: Optional[datetime] = Field(None, description="Call end timestamp")
    duration_sec: Optional[int] = Field(None, description="Total call duration in seconds")
    
    # v0.5 Extensions
    parent_session_id: Optional[str] = Field(None, description="Parent session for hierarchical grouping")
    correlation_id: Optional[str] = Field(None, description="Cross-system correlation identifier")
    channel: Optional[ChannelType] = Field(None, description="Communication channel type")
    direction: Optional[CallDirection] = Field(None, description="Call direction (inbound/outbound)")
    from_: Optional[str] = Field(None, alias="from", description="Originating phone number or identifier")
    to: Optional[str] = Field(None, description="Destination phone number or identifier")
    caller_id: Optional[str] = Field(None, description="Caller identification (anonymized)")
    geographic_region: Optional[str] = Field(None, description="Geographic region of the call")
    capabilities_invoked: List[Union[str, CapabilityInvocation]] = Field(
        default_factory=list, 
        description="List of capabilities invoked (backward compatible with v0.3 strings)"
    )
```
#### Channel and Direction Support

VCP v0.5 introduces dual support for channels:

```python
class ChannelType(str, Enum):
    """Communication channel types"""
    # Traditional channel types
    PHONE = "phone"
    WEB = "web"
    MOBILE = "mobile"
    EMBED = "embed"
    API = "api"
    WEBSOCKET = "websocket"
    
    # Directional channels (backward compatibility with v0.4)
    INBOUND = "inbound"
    OUTBOUND = "outbound"

class CallDirection(str, Enum):
    """Call direction types (preferred approach for v0.5+)"""
    INBOUND = "inbound"
    OUTBOUND = "outbound"
```
**Implementation Guidelines:**
- **Preferred**: Use `channel` for medium (phone/web) + `direction` for directionality
- **Legacy**: Use `channel="inbound"` or `channel="outbound"` for backward compatibility
- **Transformation**: Systems should map legacy format to preferred format when possible

#### Capability Invocations

Capabilities can be specified as simple strings (v0.3 compatibility) or detailed objects:

```python
class CapabilityType(str, Enum):
    """Types of capabilities that can be invoked during calls"""
    TOOL_CALL = "tool_call"
    FUNCTION_CALL = "function_call"
    API_CALL = "api_call"
    WEBHOOK = "webhook"
    INTEGRATION = "integration"

class CapabilityInvocation(BaseModel):
    """Represents a capability that was invoked during the call"""
    capability_id: str = Field(..., description="Unique identifier for the capability")
    capability_type: CapabilityType = Field(..., description="Type of capability invoked")
    invoked_at: datetime = Field(..., description="When the capability was invoked")
    duration_ms: Optional[int] = Field(None, description="Duration of capability execution in milliseconds")
    success: bool = Field(..., description="Whether the capability executed successfully")
    error_message: Optional[str] = Field(None, description="Error message if capability failed")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional capability-specific metadata")
```
### 2. Model Selection (`model_selection`)

Comprehensive AI model selection and attribution:

```python
class ModelSelection(BaseModel):
    """Model selection information (enhanced from v0.3)"""
    policy_id: str = Field(..., description="Policy used for model selection")
    resolved_at: datetime = Field(..., description="When model selection was resolved")
    roles: Dict[ModelRole, ModelRoleInfo] = Field(..., description="Model information by role")
    
    # v0.5 Extensions
    selection_strategy: Optional[str] = Field(None, description="Strategy used for selection")
    total_selection_time_ms: Optional[float] = Field(None, description="Total time for all model selections")

class ModelRole(str, Enum):
    """AI model roles in voice processing pipeline"""
    V2V = "V2V"        # Voice-to-Voice (end-to-end)
    STT = "STT"        # Speech-to-Text
    LLM = "LLM"        # Large Language Model
    TTS = "TTS"        # Text-to-Speech
    VAD = "VAD"        # Voice Activity Detection
    ASR = "ASR"        # Automatic Speech Recognition

class ModelRoleInfo(BaseModel):
    """Information about a model role selection"""
    chosen: str = Field(..., description="Selected model identifier")
    alternatives: List[str] = Field(default_factory=list, description="Alternative models considered")
    reason: List[str] = Field(default_factory=list, description="Reasons for model selection")
    telemetry_prior: Optional[TelemetryPrior] = Field(None, description="Prior performance telemetry")
    fallback_used: bool = Field(False, description="Whether fallback model was used")
    selection_time_ms: Optional[float] = Field(None, description="Time taken for model selection")
```
### 3. Outcomes (`outcomes`)

Comprehensive outcome tracking with objective and perceived assessments:

```python
class Outcomes(BaseModel):
    """Call outcomes (enhanced from v0.3)"""
    perceived: List[str] = Field(default_factory=list, description="Perceived outcomes from user perspective")
    objective: ObjectiveOutcome = Field(..., description="Objective outcome assessment")
    perception_gap: PerceptionGap = Field(..., description="Gap between perceived and objective")
    model_outcome_attribution: ModelOutcomeAttribution = Field(..., description="Attribution to specific models")
    
    # v0.5 Extensions
    user_satisfaction_score: Optional[float] = Field(None, description="User satisfaction (0-1)")
    business_impact: Optional[Dict[str, Any]] = Field(None, description="Business impact metrics")

class OutcomeStatus(str, Enum):
    """Call outcome status"""
    SUCCESS = "success"
    FAILURE = "failure"
    PARTIAL = "partial"
    TIMEOUT = "timeout"
    ERROR = "error"
    UNKNOWN = "unknown"    # Added for cases where status cannot be determined

class ObjectiveOutcome(BaseModel):
    """Objective outcome assessment"""
    status: OutcomeStatus = Field(..., description="Overall outcome status")
    scored_criteria: List[ScoredCriteria] = Field(default_factory=list, description="List of evaluated criteria")
    metrics: Dict[str, Any] = Field(default_factory=dict, description="Outcome metrics")
    confidence: Optional[float] = Field(None, description="Confidence score (0-1)")
    assessment_time_ms: Optional[float] = Field(None, description="Time taken for assessment")
```
### 4. Human Readable Context (`hcr`)

Summary information for human consumption:

```python
class HumanReadableContext(BaseModel):
    """Human-readable context (HCR) from v0.3"""
    audience: str = Field(..., description="Target audience for this context")
    headline: str = Field(..., description="Brief headline summary")
    outcome_status: OutcomeStatus = Field(..., description="Outcome status")
    key_points: List[str] = Field(default_factory=list, description="Key points from the interaction")
    impact_metrics: Dict[str, Any] = Field(default_factory=dict, description="Impact metrics")
    
    # v0.5 Extensions
    summary: Optional[str] = Field(None, description="Detailed summary")
    recommendations: Optional[List[str]] = Field(None, description="Recommendations for improvement")
    alert_level: Optional[Literal["info", "warning", "critical"]] = Field(None, description="Alert level if applicable")
```
### 5. Artifacts (`artifacts`)

References to recordings, transcripts, and related data:

```python
class Artifacts(BaseModel):
    """Artifacts and references"""
    provider_raw_payload_ref: Optional[str] = Field(None, description="Reference to raw provider payload")
    audio_recording_ref: Optional[str] = Field(None, description="Reference to audio recording")
    transcript_ref: Optional[str] = Field(None, description="Reference to full transcript")
    
    # v0.5 Extensions
    system_logs_ref: Optional[str] = Field(None, description="Reference to system logs")
    debug_artifacts: Optional[Dict[str, str]] = Field(None, description="Debug artifact references")
    compliance_records: Optional[Dict[str, str]] = Field(None, description="Compliance record references")
```
**Artifact Reference Format:**
```
# S3/Cloud Storage
s3://bucket-name/path/to/artifact.ext
gs://bucket-name/path/to/artifact.ext
azure://container/path/to/artifact.ext

# HTTP URLs
https://domain.com/api/artifacts/123/audio.wav
https://cdn.domain.com/transcripts/abc123.txt

# Internal References
internal://artifact-service/uuid
local://path/to/file.ext
```
### 6. Custom Data (`custom`)

Provider-specific and experimental data:

```python
class Custom(BaseModel):
    """Custom provider-specific data (enhanced from v0.3)"""
    provider_specific: Dict[str, CustomProviderData] = Field(
        default_factory=dict,
        description="Provider-specific custom data"
    )
    
    # v0.5 Extensions
    integrations: Optional[Dict[str, Dict[str, Any]]] = Field(None, description="Third-party integration data")
    experimental: Optional[Dict[str, Any]] = Field(None, description="Experimental features data")

class CustomProviderData(BaseModel):
    """Custom provider-specific data structure"""
    data: Dict[str, Any] = Field(..., description="Provider-specific data")
```
**Provider-Specific Data Examples:**

#### Retell AI
```json
{
  "provider_specific": {
    "retell": {
      "data": {
        "call": {
          "call_id": "Jabr9TXYYJHfvl6Syypi88rdAHYHmcq6",
          "direction": "inbound",
          "disconnection_reason": "user_hangup",
          "transcript": "Full conversation transcript...",
          "metadata": {}
        },
        "event": "call_ended"
      }
    }
  }
}
```
#### Assistable AI with Extractions
```json
{
  "provider_specific": {
    "assistable": {
      "data": {
        "call_id": "assistable_call_abc123",
        "call_type": "outbound_sales",
        "direction": "outbound",
        "extractions": {
          "contact_zip_code": "90210",
          "customer_interest_level": "high",
          "next_followup_date": "2025-10-21",
          "product_interest": "premium_package",
          "budget_range": "$500-1000",
          "decision_maker": true,
          "purchase_timeline": "within_30_days"
        }
      }
    }
  },
  "integrations": {
    "crm_system": {
      "provider": "assistable_extractions",
      "lead_score": "high",
      "contact_data": {
        "contact_zip_code": "90210",
        "customer_interest_level": "high"
      }
    },
    "sales_system": {
      "provider": "assistable_sales_intelligence",
      "opportunity_data": {
        "budget_range": "$500-1000",
        "purchase_timeline": "within_30_days",
        "decision_maker": true
      },
      "qualification_score": 0.85
    }
  }
}
```
### 7. Consent Tracking (`consent`)

User consent management for compliance:

```python
class ConsentRecord(BaseModel):
    """User consent information"""
    consent_id: str = Field(..., description="Unique consent identifier")
    status: ConsentStatus = Field(..., description="Current consent status")
    granted_at: Optional[datetime] = Field(None, description="When consent was granted")
    expires_at: Optional[datetime] = Field(None, description="When consent expires")
    scope: List[str] = Field(..., description="Scope of consent (e.g., 'recording', 'analytics', 'storage')")
    version: str = Field(..., description="Consent policy version")
    user_agent: Optional[str] = Field(None, description="User agent when consent was given")
    ip_address_hash: Optional[str] = Field(None, description="Hashed IP address")

class ConsentStatus(str, Enum):
    """User consent status for data processing"""
    GRANTED = "granted"
    DENIED = "denied"
    PENDING = "pending"
    EXPIRED = "expired"
    REVOKED = "revoked"
```
### 8. Provenance (`provenance`)

Data lineage and processing history:

```python
class Provenance(BaseModel):
    """Data provenance and lineage information"""
    source_system: str = Field(..., description="System that generated this VCP record")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    created_by: Optional[str] = Field(None, description="Service/user that created this record")
    transformation_history: List[str] = Field(default_factory=list, description="History of transformations applied")
    data_retention_policy: Optional[str] = Field(None, description="Applicable data retention policy")
    compliance_flags: Optional[List[str]] = Field(None, description="Compliance flags (GDPR, CCPA, etc.)")
```
### 9. Audit Information (`audit`)

Processing and validation metadata:

```python
class Audit(BaseModel):
    """Audit information (enhanced from v0.3)"""
    received_at: datetime = Field(..., description="When the record was received")
    schema_version: str = Field(..., description="VCP schema version")
    
    # v0.5 Extensions
    processed_at: Optional[datetime] = Field(None, description="When processing completed")
    processing_duration_ms: Optional[float] = Field(None, description="Processing duration in milliseconds")
    validation_errors: Optional[List[str]] = Field(None, description="Validation errors encountered")
    checksum: Optional[str] = Field(None, description="Record checksum for integrity")
```
## Validation Rules

### Schema Validation

The VCP validator implements comprehensive validation:

```python
class VCPValidator:
    """Enhanced VCP validator supporting multiple versions"""
    
    @staticmethod
    def validate_v05(message: VCPMessage) -> Dict[str, List[str]]:
        """Validate VCP v0.5 message"""
        errors = []
        warnings = []
        
        try:
            # 1. Basic validation via pydantic
            message.model_dump()
            
            # 2. Business logic validation
            if message.vcp_payload.call.end_time and message.vcp_payload.call.start_time:
                if message.vcp_payload.call.end_time < message.vcp_payload.call.start_time:
                    errors.append("Call end_time cannot be before start_time")
            
            # 3. Capability validation
            for capability in message.vcp_payload.call.capabilities_invoked:
                if isinstance(capability, dict):
                    cap_obj = CapabilityInvocation(**capability)
                    if cap_obj.invoked_at < message.vcp_payload.call.start_time:
                        warnings.append(f"Capability {cap_obj.capability_id} invoked before call start")
            
            # 4. Consent validation
            if message.vcp_payload.consent:
                if message.vcp_payload.consent.status == ConsentStatus.EXPIRED:
                    warnings.append("User consent has expired")
                elif message.vcp_payload.consent.status == ConsentStatus.REVOKED:
                    errors.append("Cannot process data with revoked consent")
            
        except Exception as e:
            errors.append(f"Validation error: {str(e)}")
        
        return {"errors": errors, "warnings": warnings}
```
### Required Field Matrix

| Component | Required Fields | Optional Fields |
|-----------|----------------|-----------------|
| **VCPMessage** | vcp_version, vcp_payload, audit | - |
| **Call** | call_id, session_id, provider, start_time | end_time, duration_sec, channel, direction |
| **ModelSelection** | policy_id, resolved_at, roles | selection_strategy, total_selection_time_ms |
| **Outcomes** | objective, perception_gap, model_outcome_attribution | perceived, user_satisfaction_score |
| **ObjectiveOutcome** | status | scored_criteria, metrics, confidence |
| **HumanReadableContext** | audience, headline, outcome_status | key_points, summary, recommendations |
| **Audit** | received_at, schema_version | processed_at, validation_errors |

## Version Upgrade Path

### From v0.3 to v0.5

```python
def upgrade_from_v03(v03_data: Dict[str, Any]) -> VCPMessage:
    """Upgrade v0.3 message to v0.5"""
    # Add required v0.5 fields
    v03_data['vcp_version'] = "0.5"
    
    # Add provenance
    if 'provenance' not in v03_data.get('vcp_payload', {}):
        v03_data['vcp_payload']['provenance'] = {
            "source_system": v03_data['vcp_payload']['call']['provider'],
            "created_at": datetime.now(timezone.utc).isoformat(),
            "transformation_history": ["upgraded_from_v0.3"]
        }
    
    # Convert simple capabilities to enhanced format
    call = v03_data['vcp_payload']['call']
    if 'capabilities_invoked' in call and call['capabilities_invoked']:
        enhanced_caps = []
        for cap in call['capabilities_invoked']:
            if isinstance(cap, str):
                enhanced_caps.append({
                    "capability_id": cap,
                    "capability_type": "tool_call",
                    "invoked_at": call['start_time'],
                    "success": True
                })
            else:
                enhanced_caps.append(cap)
        call['capabilities_invoked'] = enhanced_caps
    
    return VCPMessage(**v03_data)
```
### Backward Compatibility

```python
def to_v03_compatible(self) -> Dict[str, Any]:
    """Convert to v0.3 compatible format"""
    data = self.model_dump()
    
    # Remove v0.5-specific fields
    if 'consent' in data['vcp_payload']:
        del data['vcp_payload']['consent']
    if 'provenance' in data['vcp_payload']:
        del data['vcp_payload']['provenance']
    
    # Simplify capabilities to string list
    call = data['vcp_payload']['call']
    if 'capabilities_invoked' in call:
        capabilities = call['capabilities_invoked']
        if isinstance(capabilities, list) and capabilities:
            simple_capabilities = []
            for cap in capabilities:
                if isinstance(cap, dict) and 'capability_id' in cap:
                    simple_capabilities.append(cap['capability_id'])
                elif isinstance(cap, str):
                    simple_capabilities.append(cap)
            call['capabilities_invoked'] = simple_capabilities
    
    data['vcp_version'] = "0.3"
    return data
```
## Implementation Examples

### Complete VCP v0.5 Message

```python
example_message = VCPMessage(
    vcp_version=VCPVersion.V05,
    vcp_payload=VCPPayload(
        call=Call(
            call_id="call_openai_v05_demo_123",
            session_id="sess_openai_demo_789",
            provider="openai",
            start_time=datetime(2025, 10, 14, 12, 0, 0, tzinfo=timezone.utc),
            end_time=datetime(2025, 10, 14, 12, 3, 15, tzinfo=timezone.utc),
            duration_sec=195,
            channel=ChannelType.WEB,
            direction=CallDirection.INBOUND,
            from_="+12345678901",
            to="+19876543210",
            capabilities_invoked=[
                CapabilityInvocation(
                    capability_id="book_appointment",
                    capability_type=CapabilityType.TOOL_CALL,
                    invoked_at=datetime(2025, 10, 14, 12, 1, 0, tzinfo=timezone.utc),
                    duration_ms=2300,
                    success=True,
                    metadata={"appointment_type": "consultation"}
                )
            ]
        ),
        model_selection=ModelSelection(
            policy_id="openai-realtime-v05",
            resolved_at=datetime(2025, 10, 14, 12, 0, 0, tzinfo=timezone.utc),
            roles={
                ModelRole.V2V: ModelRoleInfo(
                    chosen="openai.realtime-v1-2024-12",
                    alternatives=["openai.realtime-preview"],
                    reason=["native_speech_to_speech", "low_latency"]
                )
            }
        ),
        outcomes=Outcomes(
            perceived=["Appointment scheduled successfully"],
            objective=ObjectiveOutcome(
                status=OutcomeStatus.SUCCESS,
                metrics={"task_completion_rate": 1.0}
            ),
            perception_gap=PerceptionGap(
                gap_score=0.15,
                gap_class=GapClass.ALIGNED
            ),
            model_outcome_attribution=ModelOutcomeAttribution(
                roles={
                    ModelRole.V2V: ModelAttributionRole(
                        model_id="openai.realtime-v1-2024-12",
                        minutes=3.25,
                        errors=0,
                        cost_usd=0.043
                    )
                },
                kpis={"cost_per_call_usd": 0.043}
            )
        ),
        hcr=HumanReadableContext(
            audience="agent",
            headline="Appointment booking completed successfully",
            outcome_status=OutcomeStatus.SUCCESS,
            key_points=["Voice interface used", "Single tool call", "No errors"]
        ),
        artifacts=Artifacts(
            audio_recording_ref="s3://vcp-audio/sess_openai_demo_789.wav",
            transcript_ref="s3://vcp-transcripts/sess_openai_demo_789.txt"
        ),
        custom=Custom(
            provider_specific={
                "openai": CustomProviderData(data={
                    "model": "gpt-4o-realtime-preview-2024-12-17",
                    "voice": "alloy",
                    "temperature": 0.7
                })
            }
        ),
        consent=ConsentRecord(
            consent_id="consent_user_abc123_v2",
            status=ConsentStatus.GRANTED,
            scope=["recording", "analytics", "storage"],
            version="2.1"
        ),
        provenance=Provenance(
            source_system="openai.realtime_api",
            created_by="voicelens.webhook_processor",
            transformation_history=[
                "extracted_from_openai_webhook",
                "enhanced_with_capability_details",
                "validated_v0.5_schema"
            ]
        )
    ),
    audit=Audit(
        received_at=datetime(2025, 10, 14, 12, 3, 17, tzinfo=timezone.utc),
        schema_version="0.5",
        processing_duration_ms=234.7
    )
)
```
This comprehensive specification provides everything needed to implement VCP v0.5 in any programming language or environment, with complete validation rules, upgrade paths, and real-world examples.



================================================================================
📄 FILE: docs/PROVIDER_INTEGRATION_GUIDE.md
📝 TITLE: Provider Integration & Mapping Implementation Guide
📊 SIZE: 27,147 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Provider Integration & Mapping Implementation Guide

## Overview

This document provides comprehensive guidance for integrating voice AI providers into the VCP system, including webhook schemas, authentication methods, mapping rules, and transformation logic.

## Provider Integration Architecture

### Core Components

```
┌─────────────────────────────────────────────────────────────┐
│                Provider Integration System                   │
├─────────────────────────────────────────────────────────────┤
│  Provider Registry  │  Webhook Handler  │  VCP Transformer │
│  ┌─────────────────┐│  ┌─────────────────┐│  ┌─────────────────┐│
│  │ Provider Info   ││  │ Authentication  ││  │ Field Mapping   ││
│  │ Schema Defs     ││  │ Validation      ││  │ Type Conversion ││
│  │ Auth Config     ││  │ Rate Limiting   ││  │ Status Transform││
│  │ Mapping Rules   ││  │ Error Handling  ││  │ Enrichment      ││
│  └─────────────────┘│  └─────────────────┘│  └─────────────────┘│
└─────────────────────────────────────────────────────────────┘
```
### Provider Registry System

The provider registry is implemented in `provider_documentation.py`:

```python
class VoiceAIProviderRegistry:
    """Central registry for voice AI provider information"""
    
    def __init__(self):
        self.providers = self._initialize_providers()
    
    def _initialize_providers(self) -> Dict[str, ProviderInfo]:
        """Initialize provider database with research data"""
        return {
            "retell": self._create_retell_provider(),
            "bland": self._create_bland_provider(),
            "vapi": self._create_vapi_provider(),
            "elevenlabs": self._create_elevenlabs_provider(),
            "openai_realtime": self._create_openai_provider(),
            "assistable": self._create_assistable_provider()
        }
```
## Supported Providers

### 1. Retell AI Integration

**Overview**: Retell AI provides conversational voice AI with robust webhook support and signature validation.

#### Configuration

```python
@dataclass
class ProviderInfo:
    """Complete provider documentation"""
    name: str = "Retell AI"
    company: str = "Retell AI"
    website: str = "https://www.retellai.com"
    docs_url: str = "https://docs.retellai.com"
    api_base_url: str = "https://api.retellai.com"
    status_page: str = "https://status.retellai.com"
    changelog_url: str = "https://www.retellai.com/changelog"
```
#### Authentication

```python
webhook_auth = WebhookAuthConfig(
    method=AuthMethod.SIGNATURE_HEADER,
    header_name="x-retell-signature",
    secret_key_required=True,
    ip_addresses=["100.20.5.228"],
    validation_example="Retell.verify(payload, api_key, signature)"
)
```
#### Webhook Schema

```python
webhook_schemas = [
    WebhookSchema(
        event_type=WebhookEventType.CALL_ENDED,
        required_fields=[
            "event", "call.call_id", "call.from_number", 
            "call.to_number", "call.direction", "call.start_timestamp",
            "call.end_timestamp", "call.disconnection_reason"
        ],
        optional_fields=[
            "call.transcript", "call.transcript_object", 
            "call.metadata", "call.call_analysis"
        ],
        nested_objects={
            "call": ["call_id", "agent_id", "call_status", "transcript", "metadata"],
            "transcript_object": ["role", "content", "timestamp"]
        }
    )
]
```
#### VCP Mapping Rules

```python
vcp_mapping_rules = {
    "call.call_id": "call.call_id",
    "call.from_number": "call.from_",
    "call.to_number": "call.to",
    "call.direction": "call.direction",  # Uses new direction field
    "call.start_timestamp": "call.start_time",
    "call.end_timestamp": "call.end_time",
    "call.transcript": "artifacts.transcript",
    "event": "audit.event_type"
}
```
#### Example Webhook Payload

```json
{
  "event": "call_ended",
  "call": {
    "call_id": "Jabr9TXYYJHfvl6Syypi88rdAHYHmcq6",
    "from_number": "+12137771234",
    "to_number": "+12137771235",
    "direction": "inbound",
    "start_timestamp": 1714608475945,
    "end_timestamp": 1714608491736,
    "disconnection_reason": "user_hangup",
    "transcript": "Full conversation transcript...",
    "metadata": {}
  }
}
```
### 2. Vapi Integration

**Overview**: Vapi provides end-of-call reports with comprehensive conversation data.

#### Configuration

```python
"vapi": ProviderInfo(
    name="Vapi",
    company="Vapi",
    website="https://vapi.ai",
    docs_url="https://docs.vapi.ai",
    api_base_url="https://api.vapi.ai",
    status_page="https://status.vapi.ai"
)
```
#### Webhook Schema

```python
webhook_schemas = [
    WebhookSchema(
        event_type=WebhookEventType.END_OF_CALL_REPORT,
        required_fields=[
            "message.type", "message.call.id", 
            "message.endedReason", "message.artifact"
        ],
        optional_fields=[
            "message.artifact.transcript",
            "message.artifact.recording", 
            "message.artifact.messages"
        ],
        nested_objects={
            "message": ["type", "call", "endedReason", "artifact"],
            "call": ["id", "phoneNumber", "status"],
            "artifact": ["transcript", "recording", "messages"]
        }
    )
]
```
#### VCP Mapping with Status Conversion

```python
vcp_mapping_rules = {
    "message.call.id": "call.call_id",
    "message.endedReason": "outcomes.objective.status",  # Requires conversion
    "message.artifact.transcript": "artifacts.transcript",
    "message.artifact.recording": "artifacts.recording_url"
}

def _convert_vapi_ended_reason_to_status(self, ended_reason: str) -> str:
    """Convert Vapi endedReason to VCP outcome status"""
    reason = ended_reason.lower()
    
    if reason in ["completed", "success", "assistant_ended"]:
        return "success"
    elif reason in ["hangup", "user_hangup", "customer_hangup"]:
        return "success"  # Normal hangup is successful completion
    elif reason in ["timeout", "no_answer", "voicemail", "busy"]:
        return "timeout"
    elif reason in ["error", "failed", "connection_error", "technical_error"]:
        return "error"
    elif reason in ["transferred", "forwarded"]:
        return "partial"
    else:
        return "unknown"
```
### 3. Assistable AI Advanced Integration

**Overview**: Assistable AI provides the most sophisticated webhook integration with AI-powered extractions and business intelligence.

#### Configuration

```python
"assistable": ProviderInfo(
    name="Assistable AI",
    company="Assistable AI",
    website="https://assistable.ai",
    docs_url="https://docs.assistable.ai",
    api_base_url="https://api.assistable.ai",
    status_page="https://status.assistable.ai"
)
```
#### Authentication

```python
webhook_auth = WebhookAuthConfig(
    method=AuthMethod.API_KEY_HEADER,
    header_name="Authorization",
    secret_key_required=False  # Optional for some endpoints
)
```
#### Complex Webhook Schema

```python
webhook_schemas = [
    WebhookSchema(
        event_type=WebhookEventType.CALL_ENDED,
        required_fields=[
            "call_id", "call_type", "direction", "to", "from",
            "disconnection_reason", "call_completion", "assistant_task_completion",
            "call_time_ms", "call_time_seconds", "start_timestamp", "end_timestamp"
        ],
        optional_fields=[
            "args", "metadata", "contact_id", "user_sentiment", "call_summary",
            "call_completion_reason", "recording_url", "full_transcript",
            "added_to_wallet", "extractions"
        ],
        nested_objects={
            "args": ["contact_address_zip_code"],  # Dynamic - customizable per assistant
            "metadata": ["contact_id", "location_id"],  # Dynamic - customizable per assistant
            "extractions": []  # Completely dynamic - AI-extracted data
        }
    )
]
```
#### Advanced VCP Mapping

```python
vcp_mapping_rules = {
    "call_id": "call.call_id",
    "direction": "call.direction",
    "to": "call.to",
    "from": "call.from_",
    "start_timestamp": "call.start_time",
    "end_timestamp": "call.end_time",
    "call_time_seconds": "call.duration_sec",
    "full_transcript": "artifacts.transcript",
    "recording_url": "artifacts.recording_url",
    "call_summary": "hcr.summary",
    "user_sentiment": "outcomes.user_satisfaction_score",  # Requires conversion
    "call_completion": "outcomes.objective.metrics.task_completion",
    "assistant_task_completion": "outcomes.objective.metrics.assistant_success",
    "disconnection_reason": "outcomes.objective.status",
    "extractions": "custom.provider_specific.assistable.extractions",
    "args": "custom.provider_specific.assistable.call_args",
    "metadata": "custom.provider_specific.assistable.metadata",
    "contact_id": "call.caller_id",
    "call_type": "custom.provider_specific.assistable.call_type"
}
```
#### AI Extractions Integration

Assistable AI provides dynamic AI-powered extractions that are automatically mapped to business intelligence:

```python
def _build_integrations_data(self, provider_name: str, webhook_payload: Dict[str, Any]) -> Dict[str, Any]:
    """Build integration data from webhook payload"""
    if provider_name != "assistable":
        return {}
    
    integrations = {}
    extractions = webhook_payload.get("extractions", {})
    
    if extractions:
        # Map CRM-like data from extractions
        if "customer_interest_level" in extractions or "lead_score" in extractions:
            integrations["crm_system"] = {
                "provider": "assistable_extractions",
                "lead_score": extractions.get("customer_interest_level", "unknown"),
                "contact_data": {
                    key: value for key, value in extractions.items()
                    if key.startswith(("contact_", "customer_", "lead_"))
                }
            }
        
        # Map scheduling data
        if "next_followup_date" in extractions or "appointment_" in str(extractions):
            integrations["calendar_system"] = {
                "provider": "assistable_scheduling",
                "next_action": extractions.get("next_followup_date"),
                "scheduling_data": {
                    key: value for key, value in extractions.items()
                    if any(term in key.lower() for term in ["appointment", "schedule", "meeting", "followup"])
                }
            }
        
        # Map sales/opportunity data
        sales_indicators = ["budget", "purchase", "product_interest", "decision_maker", "timeline"]
        sales_data = {
            key: value for key, value in extractions.items()
            if any(indicator in key.lower() for indicator in sales_indicators)
        }
        if sales_data:
            integrations["sales_system"] = {
                "provider": "assistable_sales_intelligence",
                "opportunity_data": sales_data,
                "qualification_score": self._calculate_qualification_score(sales_data)
            }
    
    return {"integrations": integrations} if integrations else {}
```
### 4. ElevenLabs Integration

**Overview**: ElevenLabs provides conversational AI with advanced HMAC-based webhook security.

#### Authentication

```python
webhook_auth = WebhookAuthConfig(
    method=AuthMethod.HMAC_SHA256,
    header_name="elevenlabs-signature",
    secret_key_required=True,
    ip_addresses=[
        "34.67.146.145", "34.59.11.47",    # US
        "35.204.38.71", "34.147.113.54",   # EU
        "35.185.187.110", "35.247.157.189" # Asia
    ],
    validation_example="hmac.compare_digest(signature, hmac_sha256(timestamp + payload))"
)
```
#### Webhook Validation

```python
def validate_webhook_signature(self, provider_name: str, payload: str, 
                             signature: str, secret: str = None) -> bool:
    """Validate webhook signature for a provider"""
    if provider_name == "elevenlabs":
        # ElevenLabs format: t=timestamp,v0=hash
        parts = signature.split(',')
        timestamp = parts[0].split('=')[1]
        hash_part = parts[1].split('=')[1]
        
        full_payload = f"{timestamp}.{payload}"
        calculated_hash = hmac.new(
            secret.encode('utf-8'),
            full_payload.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return hmac.compare_digest(f'v0={calculated_hash}', f'v0={hash_part}')
    
    return False
```
### 5. OpenAI Realtime API Integration

**Overview**: OpenAI Realtime API integration for real-time voice conversations.

#### Configuration

```python
"openai_realtime": ProviderInfo(
    name="OpenAI Realtime API",
    company="OpenAI",
    website="https://platform.openai.com",
    docs_url="https://platform.openai.com/docs/guides/realtime",
    api_base_url="https://api.openai.com/v1/realtime",
    status_page="https://status.openai.com"
)
```
#### Event Types

```python
supported_events = [
    WebhookEventType.STATUS_UPDATE,
    WebhookEventType.CONVERSATION_UPDATE,
    WebhookEventType.TRANSCRIPT_UPDATE
]
```
### 6. Bland AI Integration

**Overview**: Bland AI provides straightforward voice AI with bearer token authentication.

#### Configuration

```python
"bland": ProviderInfo(
    name="Bland AI",
    company="Bland AI",
    website="https://www.bland.ai",
    docs_url="https://docs.bland.ai",
    api_base_url="https://api.bland.ai"
)
```
#### Simple Authentication

```python
webhook_auth = WebhookAuthConfig(
    method=AuthMethod.BEARER_TOKEN,
    header_name="Authorization",
    secret_key_required=False
)
```
## VCP Mapping Engine Implementation

### Core Mapping Class

The `VCPMapper` class handles all provider transformations:

```python
class VCPMapper:
    """Maps provider webhooks to VCP v0.5 format"""
    
    def __init__(self, registry: VoiceAIProviderRegistry):
        self.registry = registry
    
    def map_to_vcp(self, provider_name: str, webhook_payload: Dict[str, Any]) -> Dict[str, Any]:
        """Main transformation method"""
        provider = self.registry.get_provider(provider_name)
        if not provider or not provider.vcp_mapping_rules:
            return {}
        
        vcp_data = {}
        
        # Apply mapping rules
        for provider_path, vcp_path in provider.vcp_mapping_rules.items():
            value = self._get_nested_value(webhook_payload, provider_path)
            if value is not None:
                self._apply_transformation(provider_name, provider_path, vcp_path, value, vcp_data)
        
        # Build complete VCP structure
        return self._build_vcp_structure(provider_name, vcp_data, webhook_payload)
```
### Field Mapping Logic

```python
def _get_nested_value(self, data: Dict[str, Any], path: str) -> Any:
    """Get value from nested dictionary using dot notation"""
    keys = path.split('.')
    value = data
    
    for key in keys:
        if isinstance(value, dict) and key in value:
            value = value[key]
        else:
            return None
    
    return value

def _set_nested_value(self, data: Dict[str, Any], path: str, value: Any):
    """Set value in nested dictionary using dot notation"""
    keys = path.split('.')
    current = data
    
    for key in keys[:-1]:
        if key not in current:
            current[key] = {}
        current = current[key]
    
    current[keys[-1]] = value
```
### Transformation Logic

```python
def _apply_transformation(self, provider_name: str, provider_path: str, 
                         vcp_path: str, value: Any, vcp_data: Dict[str, Any]):
    """Apply provider-specific transformations"""
    
    if provider_name == "assistable":
        if provider_path == "user_sentiment":
            # Convert sentiment string to score
            sentiment_score = self._convert_sentiment_to_score(value)
            self._set_nested_value(vcp_data, vcp_path, sentiment_score)
        elif provider_path == "direction":
            # Direction maps to call.direction field directly
            self._set_nested_value(vcp_data, vcp_path, value)
            # Also set channel to phone for Assistable calls
            self._set_nested_value(vcp_data, "call.channel", "phone")
        elif provider_path == "disconnection_reason":
            # Convert disconnection reason to outcome status
            status = self._convert_disconnection_to_status(value)
            self._set_nested_value(vcp_data, vcp_path, status)
        else:
            self._set_nested_value(vcp_data, vcp_path, value)
    
    elif provider_name == "vapi" and provider_path == "message.endedReason":
        # Convert Vapi endedReason to VCP status
        status = self._convert_vapi_ended_reason_to_status(value)
        self._set_nested_value(vcp_data, vcp_path, status)
    
    elif provider_path.endswith(".direction") and vcp_path == "call.direction":
        # Handle direction field for any provider (Retell, etc.)
        self._set_nested_value(vcp_data, vcp_path, value)
        # Set default channel to phone for voice calls with direction
        self._set_nested_value(vcp_data, "call.channel", "phone")
    
    else:
        self._set_nested_value(vcp_data, vcp_path, value)
```
### VCP Structure Building

```python
def _build_vcp_structure(self, provider_name: str, vcp_data: Dict[str, Any], 
                        webhook_payload: Dict[str, Any]) -> Dict[str, Any]:
    """Build complete VCP structure with defaults"""
    now = datetime.now(timezone.utc)
    call_id = self._get_nested_value(vcp_data, 'call.call_id') or str(uuid.uuid4())
    session_id = self._get_nested_value(vcp_data, 'call.session_id') or f"sess_{provider_name}_{call_id[:8]}"
    
    vcp_message = {
        "vcp_version": "0.5",
        "vcp_payload": {
            "call": {
                "call_id": call_id,
                "session_id": session_id,
                "provider": provider_name,
                "start_time": now.isoformat(),
                "end_time": now.isoformat(),
                "duration_sec": 0,
                "capabilities_invoked": [],
                **vcp_data.get('call', {})
            },
            "model_selection": {
                "policy_id": f"{provider_name}_default",
                "resolved_at": now.isoformat(),
                "roles": {}
            },
            "outcomes": {
                "perceived": [],
                "objective": {
                    "status": "unknown",
                    "scored_criteria": [],
                    "metrics": {}
                },
                "perception_gap": {
                    "gap_score": 0.0,
                    "gap_class": "aligned"
                },
                "model_outcome_attribution": {
                    "roles": {},
                    "kpis": {}
                },
                **vcp_data.get('outcomes', {})
            },
            "hcr": {
                "audience": "system",
                "headline": f"{provider_name} call processed",
                "outcome_status": "success",
                "key_points": [],
                "impact_metrics": {}
            },
            "artifacts": vcp_data.get('artifacts', {}),
            "custom": {
                "provider_specific": {
                    provider_name: self._build_provider_specific_data(provider_name, webhook_payload)
                },
                **self._build_integrations_data(provider_name, webhook_payload)
            },
            "consent": {
                "consent_id": f"consent_{call_id}",
                "status": "granted",  # Default assumption for operational webhooks
                "scope": ["recording", "analytics"],
                "version": "1.0"
            },
            "provenance": {
                "source_system": f"{provider_name}_webhook_api",
                "created_at": now.isoformat(),
                "created_by": f"{provider_name}_webhook_processor",
                "transformation_history": [
                    f"received_from_{provider_name}_webhook",
                    "mapped_to_vcp_v0.5"
                ],
                "data_retention_policy": "standard_30_days",
                "compliance_flags": []
            }
        },
        "audit": {
            "received_at": now.isoformat(),
            "schema_version": "0.5"
        }
    }
    
    return vcp_message
```
## Implementation in Different Languages

### TypeScript/Node.js Implementation

```typescript
interface ProviderInfo {
  name: string;
  company: string;
  website: string;
  docs_url: string;
  vcp_mapping_rules: Record<string, string>;
  webhook_auth?: WebhookAuthConfig;
}

class ProviderRegistry {
  private providers: Map<string, ProviderInfo> = new Map();
  
  constructor() {
    this.initializeProviders();
  }
  
  private initializeProviders() {
    this.providers.set("retell", {
      name: "Retell AI",
      company: "Retell AI",
      website: "https://www.retellai.com",
      docs_url: "https://docs.retellai.com",
      vcp_mapping_rules: {
        "call.call_id": "call.call_id",
        "call.direction": "call.direction",
        "call.start_timestamp": "call.start_time",
        "call.end_timestamp": "call.end_time",
        "call.transcript": "artifacts.transcript"
      }
    });
    
    // Add other providers...
  }
  
  getProvider(name: string): ProviderInfo | undefined {
    return this.providers.get(name.toLowerCase());
  }
}

class VCPMapper {
  constructor(private registry: ProviderRegistry) {}
  
  async mapToVCP(providerName: string, webhookPayload: any): Promise<VCPMessage> {
    const provider = this.registry.getProvider(providerName);
    if (!provider) {
      throw new Error(`Unknown provider: ${providerName}`);
    }
    
    const vcpData: any = {};
    
    // Apply mapping rules
    for (const [providerPath, vcpPath] of Object.entries(provider.vcp_mapping_rules)) {
      const value = this.getNestedValue(webhookPayload, providerPath);
      if (value !== null && value !== undefined) {
        this.setNestedValue(vcpData, vcpPath, value);
      }
    }
    
    // Build VCP structure
    return this.buildVCPMessage(providerName, vcpData, webhookPayload);
  }
  
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : null;
    }, obj);
  }
  
  private setNestedValue(obj: any, path: string, value: any): void {
    const keys = path.split('.');
    const lastKey = keys.pop()!;
    const target = keys.reduce((current, key) => {
      return current[key] = current[key] || {};
    }, obj);
    target[lastKey] = value;
  }
}
```
### Python Flask Integration

```python
from flask import Flask, request, jsonify
from provider_documentation import VoiceAIProviderRegistry, VCPMapper
from vcp_v05_schema import VCPValidator

app = Flask(__name__)
registry = VoiceAIProviderRegistry()
mapper = VCPMapper(registry)
validator = VCPValidator()

@app.route('/webhook/<provider>', methods=['POST'])
def handle_webhook(provider: str):
    try:
        # 1. Validate provider
        provider_info = registry.get_provider(provider)
        if not provider_info:
            return jsonify({'error': f'Unknown provider: {provider}'}), 400
        
        # 2. Validate webhook signature (if required)
        if provider_info.webhook_auth and provider_info.webhook_auth.secret_key_required:
            signature = request.headers.get(provider_info.webhook_auth.header_name)
            if not signature or not registry.validate_webhook_signature(
                provider, request.get_data(as_text=True), signature
            ):
                return jsonify({'error': 'Invalid signature'}), 401
        
        # 3. Transform to VCP
        webhook_payload = request.get_json()
        vcp_message = mapper.map_to_vcp(provider, webhook_payload)
        
        # 4. Validate VCP schema
        validation_result = validator.validate_v05(vcp_message)
        
        # 5. Store and process (implement your storage logic here)
        # store_vcp_message(vcp_message)
        # process_analytics(vcp_message)
        
        return jsonify({
            'success': True,
            'validation': validation_result,
            'vcp_payload': vcp_message
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

if __name__ == '__main__':
    app.run(debug=True, port=8080)
```
## Testing and Validation

### Provider Integration Testing

```python
def test_provider_integration():
    """Test all provider integrations"""
    registry = VoiceAIProviderRegistry()
    mapper = VCPMapper(registry)
    
    test_cases = [
        {
            "provider": "retell",
            "webhook": {
                "event": "call_ended",
                "call": {
                    "call_id": "test_123",
                    "direction": "inbound",
                    "start_timestamp": 1714608475945,
                    "end_timestamp": 1714608491736
                }
            }
        },
        {
            "provider": "vapi",
            "webhook": {
                "message": {
                    "type": "end-of-call-report",
                    "call": {"id": "vapi_123"},
                    "endedReason": "hangup",
                    "artifact": {"transcript": "Hello world"}
                }
            }
        }
        # Add more test cases...
    ]
    
    for test_case in test_cases:
        try:
            result = mapper.map_to_vcp(test_case["provider"], test_case["webhook"])
            print(f"✅ {test_case['provider']} integration successful")
            
            # Validate VCP schema
            validator = VCPValidator()
            validation = validator.validate_v05(result)
            if validation["errors"]:
                print(f"❌ {test_case['provider']} validation errors: {validation['errors']}")
            else:
                print(f"✅ {test_case['provider']} VCP validation passed")
                
        except Exception as e:
            print(f"❌ {test_case['provider']} integration failed: {e}")
```
This comprehensive guide provides everything needed to integrate any voice AI provider into the VCP system, with detailed examples, authentication methods, and transformation logic for all supported providers.



================================================================================
📄 FILE: docs/DEPLOYMENT_OPERATIONS_GUIDE.md
📝 TITLE: VCP System Deployment & Operations Guide
📊 SIZE: 24,088 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VCP System Deployment & Operations Guide

## Overview

This guide provides comprehensive instructions for deploying, configuring, and operating the VCP system in production environments. It covers Docker deployment, Kubernetes orchestration, monitoring setup, and operational best practices.

## System Requirements

### Minimum Requirements
- **CPU**: 2 cores
- **RAM**: 4GB
- **Storage**: 20GB
- **Python**: 3.9+
- **Database**: PostgreSQL 12+ or SQLite 3+

### Recommended Production Requirements
- **CPU**: 4+ cores
- **RAM**: 8GB+
- **Storage**: 100GB+ (SSD preferred)
- **Database**: PostgreSQL 14+ with connection pooling
- **Cache**: Redis 6+
- **Load Balancer**: nginx or similar

## Environment Configuration

### Core Environment Variables

```bash
# Service Configuration
SERVICE_HOST=0.0.0.0
SERVICE_PORT=8080
SERVICE_ENV=production  # development, staging, production

# Database Configuration
DATABASE_URL=postgresql://user:password@localhost:5432/voicelens
DATABASE_POOL_SIZE=20
DATABASE_MAX_OVERFLOW=10

# Redis Configuration (optional but recommended)
REDIS_URL=redis://localhost:6379/0
REDIS_POOL_SIZE=10

# Webhook Security
WEBHOOK_SECRET_RETELL=your_retell_webhook_secret
WEBHOOK_SECRET_ELEVENLABS=your_elevenlabs_webhook_secret
WEBHOOK_SECRET_VAPI=your_vapi_secret

# Provider API Keys
RETELL_API_KEY=your_retell_api_key
VAPI_API_KEY=your_vapi_api_key
ASSISTABLE_API_KEY=your_assistable_api_key
ELEVENLABS_API_KEY=your_elevenlabs_api_key
OPENAI_API_KEY=your_openai_api_key

# Monitoring Configuration
MONITORING_ENABLED=true
CRON_SCHEDULE="0 */6 * * *"  # Every 6 hours
ALERT_WEBHOOK_URL=https://hooks.slack.com/your/webhook/url

# Security
SECRET_KEY=your_secret_key_here
CORS_ORIGINS=https://yourdomain.com,https://dashboard.yourdomain.com

# Logging
LOG_LEVEL=INFO  # DEBUG, INFO, WARNING, ERROR
LOG_FORMAT=json  # json, text
```
### Security Configuration

```bash
# SSL/TLS (recommended for production)
SSL_CERT_PATH=/etc/ssl/certs/voicelens.crt
SSL_KEY_PATH=/etc/ssl/private/voicelens.key

# Authentication (if implementing auth)
JWT_SECRET_KEY=your_jwt_secret
JWT_EXPIRATION_HOURS=24

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60
RATE_LIMIT_BURST=10

# IP Whitelisting for webhooks (comma-separated)
ALLOWED_WEBHOOK_IPS=100.20.5.228,34.67.146.145,35.204.38.71
```
## Docker Deployment

### Production Dockerfile

```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV SERVICE_ENV=production

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential \
        curl \
        cron \
        postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Create app directory
WORKDIR /app

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Create non-root user
RUN groupadd -r voicelens && useradd -r -g voicelens voicelens

# Copy application code
COPY --chown=voicelens:voicelens . .

# Set up monitoring cron jobs
COPY scripts/setup_monitoring_cron.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/setup_monitoring_cron.sh
RUN /usr/local/bin/setup_monitoring_cron.sh

# Create necessary directories
RUN mkdir -p /app/logs /app/data \
    && chown -R voicelens:voicelens /app/logs /app/data

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:${SERVICE_PORT:-8080}/health || exit 1

# Switch to non-root user
USER voicelens

# Expose port
EXPOSE 8080

# Start application
CMD ["python", "voicelens_ops_app.py"]
```
### Docker Compose Configuration

```yaml
# docker-compose.yml
version: '3.8'

services:
  voicelens-app:
    build: .
    container_name: voicelens-app
    ports:
      - "8080:8080"
    environment:
      - SERVICE_HOST=0.0.0.0
      - SERVICE_PORT=8080
      - DATABASE_URL=postgresql://voicelens:password@postgres:5432/voicelens
      - REDIS_URL=redis://redis:6379/0
      - MONITORING_ENABLED=true
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
    restart: unless-stopped
    networks:
      - voicelens-network

  postgres:
    image: postgres:14-alpine
    container_name: voicelens-postgres
    environment:
      - POSTGRES_DB=voicelens
      - POSTGRES_USER=voicelens
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    networks:
      - voicelens-network

  redis:
    image: redis:7-alpine
    container_name: voicelens-redis
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - voicelens-network

  nginx:
    image: nginx:alpine
    container_name: voicelens-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/ssl/certs
    depends_on:
      - voicelens-app
    restart: unless-stopped
    networks:
      - voicelens-network

volumes:
  postgres_data:
  redis_data:

networks:
  voicelens-network:
    driver: bridge
```
### Nginx Configuration

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream voicelens-app {
        server voicelens-app:8080;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=webhook:10m rate=10r/m;
    limit_req_zone $binary_remote_addr zone=api:10m rate=60r/m;

    server {
        listen 80;
        server_name yourdomain.com;
        
        # Redirect HTTP to HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name yourdomain.com;

        # SSL Configuration
        ssl_certificate /etc/ssl/certs/voicelens.crt;
        ssl_certificate_key /etc/ssl/private/voicelens.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Security Headers
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # Webhook endpoints (stricter rate limiting)
        location ~* ^/webhook/ {
            limit_req zone=webhook burst=5 nodelay;
            
            # IP whitelist for webhooks
            allow 100.20.5.228;      # Retell AI
            allow 34.67.146.145;     # ElevenLabs US
            allow 35.204.38.71;      # ElevenLabs EU
            deny all;

            proxy_pass http://voicelens-app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Webhook-specific timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
        }

        # API endpoints
        location ~* ^/api/ {
            limit_req zone=api burst=10 nodelay;

            proxy_pass http://voicelens-app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS headers
            add_header Access-Control-Allow-Origin "https://dashboard.yourdomain.com" always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Content-Type, Authorization" always;
        }

        # Dashboard and static files
        location / {
            proxy_pass http://voicelens-app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Cache static files
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                expires 30d;
                add_header Cache-Control "public, immutable";
            }
        }

        # Health check endpoint (no rate limiting)
        location /health {
            access_log off;
            proxy_pass http://voicelens-app;
        }
    }
}
```
## Kubernetes Deployment

### Namespace and ConfigMap

```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: voicelens
---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: voicelens-config
  namespace: voicelens
data:
  SERVICE_HOST: "0.0.0.0"
  SERVICE_PORT: "8080"
  SERVICE_ENV: "production"
  MONITORING_ENABLED: "true"
  CRON_SCHEDULE: "0 */6 * * *"
  LOG_LEVEL: "INFO"
  LOG_FORMAT: "json"
```
### Secrets

```yaml
# k8s/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: voicelens-secrets
  namespace: voicelens
type: Opaque
data:
  # Base64 encoded values
  DATABASE_URL: cG9zdGdyZXNxbDovL3VzZXI6cGFzc3dvcmRAbG9jYWxob3N0OjU0MzIvdm9pY2VsZW5z
  RETELL_API_KEY: eW91cl9yZXRlbGxfYXBpX2tleQ==
  VAPI_API_KEY: eW91cl92YXBpX2FwaV9rZXk=
  WEBHOOK_SECRET_RETELL: eW91cl9yZXRlbGxfd2ViaG9va19zZWNyZXQ=
  SECRET_KEY: eW91cl9zZWNyZXRfa2V5X2hlcmU=
```
### Application Deployment

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: voicelens-app
  namespace: voicelens
spec:
  replicas: 3
  selector:
    matchLabels:
      app: voicelens-app
  template:
    metadata:
      labels:
        app: voicelens-app
    spec:
      containers:
      - name: app
        image: voicelens/app:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: voicelens-secrets
              key: DATABASE_URL
        - name: RETELL_API_KEY
          valueFrom:
            secretKeyRef:
              name: voicelens-secrets
              key: RETELL_API_KEY
        envFrom:
        - configMapRef:
            name: voicelens-config
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: data
          mountPath: /app/data
      volumes:
      - name: logs
        emptyDir: {}
      - name: data
        persistentVolumeClaim:
          claimName: voicelens-data-pvc
---
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: voicelens-service
  namespace: voicelens
spec:
  selector:
    app: voicelens-app
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
---
# k8s/pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: voicelens-data-pvc
  namespace: voicelens
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
  storageClassName: fast-ssd
```
### Ingress Configuration

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: voicelens-ingress
  namespace: voicelens
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rate-limit: "60"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    secretName: voicelens-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: voicelens-service
            port:
              number: 80
```
## Database Setup

### PostgreSQL Schema

```sql
-- init.sql
-- VCP Messages Table
CREATE TABLE IF NOT EXISTS vcp_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id VARCHAR(255) NOT NULL,
    provider VARCHAR(50) NOT NULL,
    vcp_version VARCHAR(10) NOT NULL DEFAULT '0.5',
    raw_payload JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Indexed fields for fast querying
    start_time TIMESTAMP WITH TIME ZONE,
    end_time TIMESTAMP WITH TIME ZONE,
    duration_sec INTEGER,
    channel VARCHAR(20),
    direction VARCHAR(10),
    status VARCHAR(20),
    user_satisfaction_score DECIMAL(3,2),
    cost_usd DECIMAL(10,4)
);

-- Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vcp_provider_created ON vcp_messages(provider, created_at);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vcp_call_id ON vcp_messages(call_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vcp_status ON vcp_messages(status);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vcp_timerange ON vcp_messages(start_time, end_time);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vcp_provider_status ON vcp_messages(provider, status);

-- Provider Analytics Table
CREATE TABLE IF NOT EXISTS provider_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    provider VARCHAR(50) NOT NULL,
    date DATE NOT NULL,
    total_calls INTEGER DEFAULT 0,
    successful_calls INTEGER DEFAULT 0,
    failed_calls INTEGER DEFAULT 0,
    avg_duration_sec DECIMAL(10,2),
    total_cost_usd DECIMAL(10,2),
    avg_satisfaction_score DECIMAL(3,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(provider, date)
);

-- Monitoring Changes Table
CREATE TABLE IF NOT EXISTS monitoring_changes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    provider VARCHAR(50) NOT NULL,
    change_type VARCHAR(50) NOT NULL,
    change_data JSONB NOT NULL,
    detected_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    severity VARCHAR(20) DEFAULT 'info'
);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_monitoring_provider_time ON monitoring_changes(provider, detected_at);

-- Analytics Views
CREATE OR REPLACE VIEW provider_daily_stats AS
SELECT 
    provider,
    DATE(created_at) as date,
    COUNT(*) as total_calls,
    COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_calls,
    COUNT(CASE WHEN status != 'success' THEN 1 END) as failed_calls,
    AVG(duration_sec) as avg_duration_sec,
    SUM(cost_usd) as total_cost_usd,
    AVG(user_satisfaction_score) as avg_satisfaction_score
FROM vcp_messages 
WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY provider, DATE(created_at)
ORDER BY provider, date DESC;

-- Functions for analytics
CREATE OR REPLACE FUNCTION update_provider_analytics()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO provider_analytics (
        provider, date, total_calls, successful_calls, failed_calls,
        avg_duration_sec, total_cost_usd, avg_satisfaction_score
    )
    SELECT 
        NEW.provider,
        DATE(NEW.created_at),
        1,
        CASE WHEN NEW.status = 'success' THEN 1 ELSE 0 END,
        CASE WHEN NEW.status != 'success' THEN 1 ELSE 0 END,
        NEW.duration_sec,
        NEW.cost_usd,
        NEW.user_satisfaction_score
    ON CONFLICT (provider, date) 
    DO UPDATE SET
        total_calls = provider_analytics.total_calls + 1,
        successful_calls = provider_analytics.successful_calls + 
            CASE WHEN NEW.status = 'success' THEN 1 ELSE 0 END,
        failed_calls = provider_analytics.failed_calls + 
            CASE WHEN NEW.status != 'success' THEN 1 ELSE 0 END,
        avg_duration_sec = (provider_analytics.avg_duration_sec * provider_analytics.total_calls + COALESCE(NEW.duration_sec, 0)) / (provider_analytics.total_calls + 1),
        total_cost_usd = provider_analytics.total_cost_usd + COALESCE(NEW.cost_usd, 0),
        avg_satisfaction_score = (provider_analytics.avg_satisfaction_score * provider_analytics.total_calls + COALESCE(NEW.user_satisfaction_score, 0)) / (provider_analytics.total_calls + 1),
        updated_at = NOW();
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update analytics
CREATE TRIGGER update_analytics_trigger
    AFTER INSERT ON vcp_messages
    FOR EACH ROW
    EXECUTE FUNCTION update_provider_analytics();
```
## Monitoring and Alerting

### Monitoring Setup Script

```bash
#!/bin/bash
# scripts/setup_monitoring_cron.sh

# Create cron job for provider monitoring
CRON_CMD="0 */6 * * * cd /app && python monitor_provider_changes.py >> /app/logs/monitoring.log 2>&1"

# Add to crontab
echo "$CRON_CMD" | crontab -

# Create log rotation
cat > /etc/logrotate.d/voicelens << EOF
/app/logs/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 0644 voicelens voicelens
    postrotate
        /usr/bin/killall -USR1 python || true
    endscript
}
EOF

echo "Monitoring cron job and log rotation configured"
```
### Health Check Endpoint

```python
# From voicelens_ops_app.py - Enhanced health check
@app.route('/health')
def health_check():
    """Comprehensive health check endpoint"""
    try:
        # Check database connectivity
        db_status = check_database_connection()
        
        # Check Redis connectivity (if configured)
        redis_status = check_redis_connection()
        
        # Check provider API connectivity
        provider_status = check_provider_apis()
        
        # System metrics
        import psutil
        system_status = {
            "cpu_percent": psutil.cpu_percent(interval=1),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent
        }
        
        # Overall status
        all_healthy = (
            db_status.get("healthy", False) and
            redis_status.get("healthy", True) and  # Redis is optional
            all(p.get("healthy", False) for p in provider_status.values())
        )
        
        status_code = 200 if all_healthy else 503
        
        return jsonify({
            "status": "healthy" if all_healthy else "unhealthy",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "version": "1.0.0",
            "database": db_status,
            "redis": redis_status,
            "providers": provider_status,
            "system": system_status,
            "deployment_modes": ["native", "hosted_ai"]
        }), status_code
        
    except Exception as e:
        return jsonify({
            "status": "error",
            "error": str(e),
            "timestamp": datetime.now(timezone.utc).isoformat()
        }), 500
```
### Prometheus Metrics

```python
# Optional: Prometheus metrics integration
from prometheus_client import Counter, Histogram, Gauge, generate_latest

# Metrics
webhook_requests_total = Counter('voicelens_webhook_requests_total', 
                                'Total webhook requests', ['provider', 'status'])
webhook_processing_time = Histogram('voicelens_webhook_processing_seconds',
                                  'Webhook processing time', ['provider'])
active_connections = Gauge('voicelens_active_connections',
                          'Active database connections')

@app.route('/metrics')
def metrics():
    """Prometheus metrics endpoint"""
    return generate_latest(), 200, {'Content-Type': 'text/plain; charset=utf-8'}
```
## Backup and Recovery

### Database Backup Script

```bash
#!/bin/bash
# scripts/backup.sh

set -e

# Configuration
DB_NAME="voicelens"
DB_USER="voicelens"
BACKUP_DIR="/app/backups"
S3_BUCKET="voicelens-backups"
DATE=$(date +%Y%m%d_%H%M%S)

# Create backup directory
mkdir -p $BACKUP_DIR

# Create database dump
pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME > $BACKUP_DIR/voicelens_$DATE.sql

# Compress backup
gzip $BACKUP_DIR/voicelens_$DATE.sql

# Upload to S3 (optional)
if [ -n "$S3_BUCKET" ]; then
    aws s3 cp $BACKUP_DIR/voicelens_$DATE.sql.gz s3://$S3_BUCKET/database/
fi

# Clean up old backups (keep last 30 days)
find $BACKUP_DIR -name "voicelens_*.sql.gz" -mtime +30 -delete

echo "Backup completed: voicelens_$DATE.sql.gz"
```
### Recovery Procedure

```bash
#!/bin/bash
# scripts/recovery.sh

BACKUP_FILE=$1
DB_NAME="voicelens"
DB_USER="voicelens"

if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: $0 <backup_file>"
    exit 1
fi

# Stop application
kubectl scale deployment voicelens-app --replicas=0 -n voicelens

# Drop and recreate database
psql -h $DB_HOST -U postgres -c "DROP DATABASE IF EXISTS $DB_NAME;"
psql -h $DB_HOST -U postgres -c "CREATE DATABASE $DB_NAME;"

# Restore from backup
gunzip -c $BACKUP_FILE | psql -h $DB_HOST -U $DB_USER -d $DB_NAME

# Restart application
kubectl scale deployment voicelens-app --replicas=3 -n voicelens

echo "Recovery completed from $BACKUP_FILE"
```
## Security Best Practices

### Application Security

1. **Environment Variables**: Never commit secrets to version control
2. **Input Validation**: Validate all webhook payloads
3. **Rate Limiting**: Implement rate limiting for all endpoints
4. **IP Whitelisting**: Restrict webhook endpoints to known provider IPs
5. **HTTPS Only**: Use TLS encryption for all communications
6. **Security Headers**: Implement proper HTTP security headers

### Webhook Security

```python
# Enhanced webhook validation
def validate_webhook_request(provider: str, request):
    """Comprehensive webhook validation"""
    
    # 1. IP validation
    client_ip = request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr)
    if not is_ip_whitelisted(provider, client_ip):
        raise SecurityError(f"Invalid IP {client_ip} for provider {provider}")
    
    # 2. Signature validation
    if not validate_webhook_signature(provider, request):
        raise SecurityError("Invalid webhook signature")
    
    # 3. Rate limiting
    if is_rate_limited(client_ip):
        raise RateLimitError("Rate limit exceeded")
    
    # 4. Payload validation
    payload = request.get_json()
    if not payload:
        raise ValidationError("Empty payload")
    
    # 5. Schema validation
    if not validate_webhook_schema(provider, payload):
        raise ValidationError("Invalid webhook schema")
    
    return True
```
## Performance Optimization

### Database Optimization

```sql
-- Performance optimization queries
ANALYZE vcp_messages;

-- Index usage monitoring
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes 
WHERE schemaname = 'public' 
ORDER BY idx_scan DESC;

-- Query performance monitoring
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    max_time
FROM pg_stat_statements 
WHERE query LIKE '%vcp_messages%'
ORDER BY total_time DESC;
```
### Application Optimization

```python
# Connection pooling configuration
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=20,
    max_overflow=10,
    pool_pre_ping=True,
    pool_recycle=3600
)

# Redis caching
import redis
redis_client = redis.Redis.from_url(REDIS_URL, decode_responses=True)

def get_provider_info_cached(provider_name: str):
    """Cache provider information"""
    cache_key = f"provider:{provider_name}"
    cached = redis_client.get(cache_key)
    
    if cached:
        return json.loads(cached)
    
    provider_info = registry.get_provider(provider_name)
    if provider_info:
        redis_client.setex(cache_key, 3600, json.dumps(asdict(provider_info)))
    
    return provider_info
```
This comprehensive deployment and operations guide provides everything needed to successfully deploy, monitor, and maintain the VCP system in production environments with high availability, security, and performance.



================================================================================
📄 FILE: README.md
📝 TITLE: VoiceLens Scripts
📊 SIZE: 13,125 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VoiceLens Scripts

VoiceLens provider documentation and monitoring scripts for voice AI webhook management.

## Overview

This repository contains the comprehensive VoiceLens system for managing voice AI providers and implementing the Voice Context Protocol (VCP) v0.5. It provides unified webhook processing, provider monitoring, and operational management tools for voice AI integrations.

### Key Components

- **🔧 VCP v0.5 Schema** (`vcp_v05_schema.py`): Complete Voice Context Protocol implementation with validation, backward compatibility, and migration tools
- **📚 Provider Documentation** (`provider_documentation.py`): Webhook mappings and documentation for major voice AI providers (Retell, Bland, Vapi, ElevenLabs, OpenAI)  
- **📊 Provider Monitoring** (`provider_monitoring.py`): Change detection and health monitoring system with automated alerts
- **🎛️ Operations Dashboard** (`voicelens_ops_app.py`): Web-based management interface for testing, monitoring, and analytics

### Voice Context Protocol (VCP) v0.5

VCP v0.5 is the comprehensive voice AI interaction schema that extends the real v0.3 production structure with advanced features:

- **Session Correlation**: Hierarchical session tracking and cross-system correlation
- **Enhanced Capabilities**: Rich capability tracking with timing, success metrics, and metadata
- **Consent Management**: GDPR/CCPA compliant user consent tracking
- **Data Provenance**: Complete data lineage and transformation history
- **Business Impact**: Revenue attribution, user satisfaction, and conversion tracking
- **Backward Compatibility**: Full v0.3 compatibility with automatic upgrade tools

## Quick Start

### Installation

```bash
# Clone repository
git clone <repository-url>
cd voicelens-scripts

# Set up Python environment
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
```
### Basic Usage

```bash
# Test VCP v0.5 schema
python vcp_v05_schema.py

# Test provider webhook mapping
python provider_documentation.py

# Run operations dashboard
python voicelens_ops_app.py
# Access at http://localhost:5000

# Start provider monitoring
python provider_monitoring.py --daemon
```
## Core Features

### 1. Voice Context Protocol (VCP) v0.5

Complete implementation of the Voice Context Protocol with comprehensive validation:

```python
from vcp_v05_schema import VCPValidator, VCPMessage, create_example_v05_message

# Create and validate VCP message
example = create_example_v05_message()
validator = VCPValidator()
results = validator.validate_v05(example)

# Upgrade from v0.3
v05_message = validator.upgrade_from_v03(v03_data)

# Convert to v0.3 compatibility  
v03_compatible = example.to_v03_compatible()
```
### 2. Provider Webhook Integration

Unified webhook processing for major voice AI providers:

```python
from provider_documentation import VoiceAIProviderRegistry, VCPMapper

# Map webhook to VCP
registry = VoiceAIProviderRegistry()
mapper = VCPMapper(registry)

vcp_result = mapper.map_to_vcp("retell", webhook_payload)
# Returns standardized VCP v0.5 structure
```
**Supported Providers:**
- **Retell AI**: Complete webhook and authentication support
- **Bland AI**: Post-call transcription and analysis webhooks
- **Vapi**: End-of-call reports and status updates
- **ElevenLabs**: Voice synthesis completion webhooks
- **OpenAI Realtime API**: Conversation and status updates

### 3. Provider Monitoring System

Automated monitoring with change detection and health checks:

```python
from provider_monitoring import VoiceLensMonitoringSystem

# Initialize monitoring
monitor = VoiceLensMonitoringSystem()

# Run monitoring cycle
monitor.run_monitoring_cycle()

# Check recent changes
changes = monitor.get_recent_changes(hours=24)

# Health status
health = monitor.check_provider_health("retell")
```
**Monitoring Features:**
- Documentation change detection
- API health monitoring
- RSS feed monitoring for changelogs
- Slack/email notifications
- Historical change tracking

### 4. Operations Dashboard

Web-based management interface with comprehensive tools:

- **Provider Management**: View and compare all voice AI providers
- **Webhook Testing**: Test webhook transformations in real-time
- **VCP Validation**: Validate and transform VCP messages
- **Analytics**: Performance metrics and success rates
- **Change Monitoring**: Real-time provider change notifications

## Advanced Usage

### Custom Provider Integration

Add support for new voice AI providers:

```python
from provider_documentation import ProviderInfo, WebhookAuthConfig, WebhookSchema
from provider_documentation import AuthMethod, WebhookEventType

# Define provider
new_provider = ProviderInfo(
    name="New Voice AI",
    company="New Voice AI Inc",
    website="https://newvoiceai.com",
    docs_url="https://docs.newvoiceai.com",
    api_base_url="https://api.newvoiceai.com",
    webhook_auth=WebhookAuthConfig(
        method=AuthMethod.HMAC_SHA256,
        header_name="X-NewVoiceAI-Signature",
        secret_key_required=True
    ),
    supported_events=[WebhookEventType.CALL_ENDED],
    vcp_mapping_rules={
        "call_id": "call.call_id",
        "duration": "call.duration_sec",
        "transcript": "artifacts.transcript"
    }
)

# Register provider
registry.add_provider("newvoiceai", new_provider)
```
### Custom VCP Extensions

Extend VCP v0.5 for specific use cases:

```python
from vcp_v05_schema import VCPMessage, Custom

# Create custom VCP message
message = VCPMessage(
    vcp_version="0.5",
    vcp_payload=VCPPayload(
        # ... standard fields ...
        custom=Custom(
            integrations={
                "crm_system": {
                    "provider": "salesforce",
                    "contact_id": "003XX000000abc123",
                    "opportunity_created": True
                }
            },
            experimental={
                "sentiment_analysis": {
                    "overall_sentiment": 0.8,
                    "sentiment_trajectory": "improving"
                }
            }
        )
    ),
    audit=Audit(
        received_at=datetime.now(timezone.utc),
        schema_version="0.5"
    )
)
```
### Monitoring Configuration

Configure advanced monitoring with custom rules:

```python
from provider_monitoring import ChangeType, SeverityLevel

# Custom monitoring rules
monitor = VoiceLensMonitoringSystem()
monitor.add_monitoring_rule(
    provider="retell",
    url_pattern="https://docs.retellai.com/webhooks/*",
    change_types=[ChangeType.API_CHANGE, ChangeType.SCHEMA_CHANGE],
    severity=SeverityLevel.HIGH,
    notification_channels=["slack", "email"]
)

# Custom severity assessment
def assess_change_severity(change_event):
    if "breaking" in change_event.description.lower():
        return SeverityLevel.CRITICAL
    elif "webhook" in change_event.description.lower():
        return SeverityLevel.HIGH
    else:
        return SeverityLevel.MEDIUM
```
## Configuration

### Environment Variables

Create `.env` file:

```bash
# Database
DATABASE_URL=sqlite:///voicelens_ops.db
MONITORING_DATABASE=monitoring.db

# Notifications  
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
EMAIL_SMTP_HOST=smtp.gmail.com
EMAIL_FROM=alerts@yourdomain.com

# Provider API Keys (optional)
RETELL_API_KEY=your-retell-key
BLAND_API_KEY=your-bland-key
VAPI_API_KEY=your-vapi-key
ELEVENLABS_API_KEY=your-elevenlabs-key
OPENAI_API_KEY=your-openai-key
```
### Advanced Configuration

Create `config.yaml` for production:

```yaml
monitoring:
  interval_minutes: 30
  providers:
    retell:
      enabled: true
      priority: high
    bland:
      enabled: true
      priority: medium

notifications:
  slack:
    channel: "#voice-ai-alerts"
    min_severity: medium
  email:
    recipients: ["ops@company.com"](
    min_severity: high

dashboard:
  host: "0.0.0.0"
  port: 5000
  features:
    webhook_testing: true
    analytics: true
```
## Deployment

### Production Deployment

```bash
# Install to system location
sudo mkdir -p /opt/voicelens
sudo cp -r . /opt/voicelens/

# Create systemd services
sudo systemctl enable voicelens-dashboard
sudo systemctl enable voicelens-monitoring
sudo systemctl start voicelens-dashboard voicelens-monitoring
```
### Docker Deployment

```bash
# Build and run with Docker Compose
docker-compose up -d

# Scale services
docker-compose up -d --scale voicelens-dashboard=2
```
See [DEPLOYMENT.md](DEPLOYMENT.md)) for comprehensive deployment guides including systemd, Docker, Kubernetes, and cloud deployments.

## API Reference

### VCP v0.5 Schema API

```python
# Core Classes
VCPMessage          # Main VCP message structure
VCPPayload          # Core payload data
Call                # Enhanced call information
ModelSelection      # Model selection details
Outcomes            # Call outcomes and attribution
ConsentRecord       # User consent tracking
Provenance          # Data lineage information

# Validation
VCPValidator.validate_v05(message)
VCPValidator.upgrade_from_v03(v03_data)

# Utilities
message.compute_checksum()
message.to_v03_compatible()
```
### Provider Documentation API

```python
# Registry Management
registry = VoiceAIProviderRegistry()
provider = registry.get_provider("retell")
all_providers = registry.get_all_providers()

# Webhook Mapping
mapper = VCPMapper(registry)
vcp_result = mapper.map_to_vcp(provider_name, webhook_payload)

# Signature Validation
is_valid = registry.validate_webhook_signature(
    provider_name, payload, signature, secret
)
```
### Monitoring API

```python
# Monitoring System
monitor = VoiceLensMonitoringSystem()
monitor.run_monitoring_cycle()

# Change Detection
changes = monitor.get_recent_changes(hours=24)
health = monitor.check_provider_health(provider_name)

# Notifications
monitor.send_notification(change_event, channels=["slack"])
```
### Operations Dashboard API

RESTful API endpoints:

- `GET /api/providers` - List all providers
- `GET /api/providers/{name}` - Provider details
- `POST /api/webhook-test` - Test webhook transformation
- `GET /api/monitoring/changes` - Recent changes
- `GET /api/monitoring/health` - Service health status
- `GET /api/analytics/transformation-stats` - Performance analytics

## Migration from v0.3/v0.4

### Automatic Migration

```python
from vcp_v05_schema import VCPValidator

# Upgrade v0.3 to v0.5
validator = VCPValidator()
v05_message = validator.upgrade_from_v03(v03_data)
```
### Key Changes in v0.5

- **Enhanced Capabilities**: Rich capability tracking with metadata
- **Session Correlation**: Parent sessions and correlation IDs
- **Consent Management**: GDPR/CCPA compliance features
- **Data Provenance**: Complete transformation history
- **Business Metrics**: Revenue attribution and satisfaction scores
- **Backward Compatibility**: Full v0.3 compatibility maintained

See [VCP_V0.5_CHANGELOG.md]((VCP_V0.5_CHANGELOG.md)) for complete migration guide.

## Testing

```bash
# Run all tests
pytest

# Test specific components
python vcp_v05_schema.py
python provider_documentation.py
python provider_monitoring.py --test

# Validate webhook transformations
python -c "
from provider_documentation import VCPMapper, VoiceAIProviderRegistry
registry = VoiceAIProviderRegistry()
mapper = VCPMapper(registry)
result = mapper.map_to_vcp('retell', test_payload)
print('Mapping successful:', bool(result))
"
```
## Contributing

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Add tests for new functionality
4. Ensure all tests pass (`pytest`)
5. Commit changes (`git commit -m 'Add amazing feature'`)
6. Push to branch (`git push origin feature/amazing-feature`)
7. Open Pull Request

### Development Setup

```bash
# Install in development mode
pip install -e .

# Install development dependencies
pip install pytest black flake8 pytest-cov

# Run code formatting
black .
flake8 .

# Run tests with coverage
pytest --cov=. --cov-report=html
```
## Changelog

### v0.5.0 (Current)
- ✅ Complete VCP v0.5 schema implementation
- ✅ Provider documentation for 5+ major providers
- ✅ Advanced monitoring with change detection
- ✅ Operations dashboard with analytics
- ✅ Full backward compatibility with v0.3
- ✅ Comprehensive deployment guides

### v0.4.0 (Deprecated)
- ⚠️ Incomplete stub implementation (migrated to v0.5)

### v0.3.0 (Legacy)
- ✅ Basic VCP schema (production baseline)
- ✅ Core provider integrations
- ✅ Basic webhook processing

## Support & Community

- **Documentation**: Complete guides in this repository
- **Issues**: [GitHub Issues](https://github.com/your-org/voicelens-scripts/issues)
- **Contact Information**: See [CONTACT-US.md]((./CONTACT-US.md)) for all contact methods and support options
- **Community Logistics**: See [LOGISTICS.md]((./LOGISTICS.md)) for planned community sync and meeting schedules

## License

MIT License - see [LICENSE](LICENSE) for details.

## Acknowledgments

- Voice AI provider communities for webhook documentation
- VCP v0.3 production users for feedback and requirements
- Open source contributors and maintainers



================================================================================
📄 FILE: ASSISTABLE_AI_INTEGRATION.md
📝 TITLE: Assistable.ai Integration with VCP v0.5
📊 SIZE: 10,299 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Assistable.ai Integration with VCP v0.5

This document describes the comprehensive integration of Assistable.ai's post-call webhooks with the VoiceLens Voice Context Protocol (VCP) v0.5 system.

## Overview

Assistable.ai is a voice AI platform that creates self-aware AI assistants capable of autonomous operation. Their post-call webhooks provide rich data including custom extractions, sentiment analysis, and business intelligence derived from voice interactions.

## Integration Features

### ✅ **Webhook Support**
- **Authentication**: API Key Header (`Authorization`)
- **Supported Events**: 
  - `call_ended` - Complete call data with extractions
  - `post_call_transcription` - Full transcript analysis
  - `call_analyzed` - AI-driven insights and sentiment

### ✅ **Dynamic Extractions Handling**
Assistable.ai's key differentiator is its dynamic extraction capability. The integration supports:

- **Flexible Schema**: No fixed extraction fields - fully customizable per assistant
- **Business Intelligence**: Automatic mapping of common business data patterns
- **Lead Qualification**: Intelligent scoring based on extracted data
- **Integration Mapping**: Automatic CRM, calendar, and sales system integrations

### ✅ **VCP v0.5 Mapping**

#### Core Call Data
```json
{
  "call_id": "assistable_call_123",
  "call_type": "outbound_sales", 
  "direction": "outbound",          // → mapped to channel: "phone"
  "to": "+1234567890",
  "from": "+1987654321",
  "start_timestamp": 1703001600,    // → Unix timestamp conversion
  "end_timestamp": 1703001785,
  "call_time_seconds": 185,
  "disconnection_reason": "completed", // → mapped to outcome status
}
```
#### Enhanced Sentiment Analysis
```json
{
  "user_sentiment": "positive"      // → converted to score: 0.8
}
```
**Sentiment Conversion Mapping:**
- `very_positive` → 1.0
- `positive` → 0.8
- `slightly_positive` → 0.6
- `neutral` → 0.5
- `slightly_negative` → 0.4
- `negative` → 0.2
- `very_negative` → 0.0

#### Task Completion Tracking
```json
{
  "call_completion": true,
  "call_completion_reason": "task_completed",
  "assistant_task_completion": true
}
```
#### Dynamic Extractions Example
```json
{
  "extractions": {
    // Contact Data
    "contact_zip_code": "90210",
    "contact_company": "TechCorp Solutions Inc",
    "contact_title": "CTO",
    
    // Lead Qualification
    "customer_interest_level": "high",
    "lead_score": 95,
    "decision_maker": true,
    
    // Product Interest
    "product_interest": "enterprise_ai_platform",
    "use_case": "customer_service_automation",
    "integration_requirements": ["salesforce", "slack", "zendesk"],
    
    // Budget & Timeline
    "budget_range": "$50000-100000",
    "budget_approved": true,
    "purchase_timeline": "within_30_days",
    "implementation_timeline": "q1_2026",
    
    // Next Steps
    "next_followup_date": "2025-10-16",
    "demo_requested": true,
    "stakeholders_to_include": ["CTO", "Head_of_Support"]
  }
}
```
## VCP v0.5 Output Structure

### Standard VCP Fields
All standard VCP v0.5 fields are populated including:
- `call` - Enhanced with Assistable.ai specific data
- `model_selection` - Default policy assignment
- `outcomes` - Sentiment scores, task completion, business impact
- `hcr` - Human-readable context with call summary
- `artifacts` - Transcript and recording references
- `audit` - Processing metadata and validation

### Assistable.ai Specific Custom Data
```json
{
  "custom": {
    "provider_specific": {
      "assistable": {
        "data": {...},              // Original webhook payload
        "extractions": {...},       // AI-extracted data
        "call_args": {...},         // Assistant parameters
        "metadata": {...},          // Call metadata
        "task_completion": {
          "call_completed": true,
          "assistant_completed": true,
          "completion_reason": "all_objectives_met"
        },
        "analytics": {
          "added_to_wallet": false,
          "user_sentiment_raw": "positive",
          "disconnection_reason": "completed_successfully"
        }
      }
    },
    "integrations": {
      "crm_system": {
        "provider": "assistable_extractions",
        "lead_score": "high",
        "contact_data": {...}
      },
      "calendar_system": {
        "provider": "assistable_scheduling",
        "next_action": "2025-10-16",
        "scheduling_data": {...}
      },
      "sales_system": {
        "provider": "assistable_sales_intelligence",
        "opportunity_data": {...},
        "qualification_score": 0.70
      }
    }
  }
}
```
### Automatic Integration Mapping

#### CRM System Integration
Automatically detected when extractions contain:
- `customer_interest_level`, `lead_score`
- Fields starting with `contact_`, `customer_`, `lead_`

#### Calendar System Integration  
Automatically detected when extractions contain:
- `next_followup_date`, `appointment_*` fields
- Keywords: appointment, schedule, meeting, followup

#### Sales System Integration
Automatically detected when extractions contain:
- `budget*`, `purchase*`, `product_interest`, `decision_maker`, `*timeline`
- Includes automatic lead qualification scoring

### Lead Qualification Scoring Algorithm
```python
def calculate_qualification_score(sales_data):
    score = 0.5  # Base score
    
    # Decision maker bonus (+0.2)
    if sales_data.get("decision_maker") is True:
        score += 0.2
    
    # Budget indicators (+0.15)
    if "$" in str(budget) or "budget" in str(budget).lower():
        score += 0.15
    
    # Timeline urgency
    if "30 days" in timeline or "immediate" in timeline:
        score += 0.15  # Urgent
    elif "90 days" in timeline or "quarter" in timeline:
        score += 0.1   # Medium urgency
    
    return min(1.0, score)  # Cap at 1.0
```
## Usage Examples

### Basic Integration
```python
from provider_documentation import VoiceAIProviderRegistry, VCPMapper

registry = VoiceAIProviderRegistry()
mapper = VCPMapper(registry)

# Process Assistable.ai webhook
vcp_result = mapper.map_to_vcp("assistable", assistable_webhook_payload)

# Result is fully compliant VCP v0.5 message
assert vcp_result["vcp_version"] == "0.5"
```
### Validation & Testing
```python
from vcp_v05_schema import VCPValidator, VCPMessage

# Validate generated VCP message
vcp_message = VCPMessage(**vcp_result)
validator = VCPValidator()
validation = validator.validate_v05(vcp_message)

print(f"Errors: {validation['errors']}")     # Should be empty
print(f"Warnings: {validation['warnings']}")  # Should be empty
```
### Operations Dashboard Testing
```python
# Test in VoiceLens Operations Dashboard
# 1. Navigate to http://localhost:5000
# 2. Go to "Webhook Testing" tab
# 3. Select "assistable" provider
# 4. Click "Load Example" for sample payload
# 5. Click "Run Test" to see VCP v0.5 transformation
```
## Key Benefits

### 🎯 **Complete Data Preservation**
- All original webhook data preserved in `custom.provider_specific.assistable.data`
- No data loss during VCP transformation
- Full traceability and audit capability

### 🤖 **Intelligent Integration Mapping**  
- Automatic detection of business patterns in extractions
- Smart mapping to CRM, calendar, and sales systems
- Lead qualification scoring without manual configuration

### 📈 **Business Intelligence Enhancement**
- Sentiment analysis with numerical scoring
- Task completion tracking and success metrics
- Revenue attribution and conversion potential

### 🔄 **Full VCP v0.5 Compliance**
- Passes all schema validation tests
- Compatible with existing VCP ecosystem
- Seamless integration with other providers

### ⚙️ **Production Ready**
- Comprehensive error handling and validation
- Fallback mechanisms for edge cases
- Extensive testing with complex extraction scenarios

## Provider Registry Status

Assistable.ai is now fully registered in the VoiceAI Provider Registry:

- **Provider Count**: 6 total providers (including Assistable.ai)
- **Supported Events**: 3 webhook events
- **Mapping Rules**: 19 field mappings
- **Authentication**: API Key Header support
- **Validation Status**: ✅ All tests passing

## Integration Testing Results

### ✅ **Basic Integration Test**
- Provider registration: ✅ Success
- Webhook mapping: ✅ 1,447 byte VCP message
- Schema validation: ✅ 0 errors, 0 warnings

### ✅ **Complex Integration Test** 
- Dynamic extractions: ✅ 25+ fields processed
- Integration mapping: ✅ 3 systems auto-detected
- Qualification scoring: ✅ 0.70 calculated score
- Schema validation: ✅ 0 errors, 0 warnings

### ✅ **Production Validation**
- VCP v0.5 compliance: ✅ Full compatibility
- Performance: ✅ ~3KB message size
- Provider comparison: ✅ Successfully compared with 5 other providers

## Deployment

The Assistable.ai integration is included in all VoiceLens deployments by default:

### Docker
```bash
docker-compose up -d
# Assistable.ai provider automatically available
```
### Systemd
```bash
sudo systemctl restart voicelens-dashboard
# Integration active immediately
```
### Development
```bash
python voicelens_ops_app.py
# Access dashboard at http://localhost:5000
# Assistable.ai available in provider testing interface
```
## Future Enhancements

### 🔮 **Planned Features**
- Real-time webhook processing with WebSocket support
- Advanced extraction pattern recognition
- Custom qualification scoring rules
- Multi-language sentiment analysis
- Integration with additional business systems

### 📊 **Analytics Enhancements**
- Extraction effectiveness tracking
- Lead conversion correlation analysis  
- Assistant performance optimization recommendations
- Business outcome attribution modeling

## Support

For Assistable.ai integration issues:

1. **Validation Problems**: Check VCP v0.5 schema compliance
2. **Mapping Issues**: Review extraction field naming conventions
3. **Integration Failures**: Verify webhook authentication setup
4. **Custom Extractions**: Ensure JSON structure compliance

**Troubleshooting**: Use the VoiceLens Operations Dashboard webhook testing interface for real-time validation and debugging.

---

**Status**: ✅ Production Ready  
**Last Updated**: October 2025  
**VCP Version**: v0.5  
**Integration Version**: v1.0



================================================================================
📄 FILE: DEPLOYMENT.md
📝 TITLE: VoiceLens Scripts Deployment Guide
📊 SIZE: 16,308 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VoiceLens Scripts Deployment Guide

This guide covers deploying the VoiceLens voice AI provider monitoring and VCP operations system.

## Overview

The VoiceLens Scripts system provides:
- **Voice Context Protocol (VCP) v0.5**: Unified schema for voice AI interactions
- **Provider Documentation**: Webhook mappings for major voice AI providers
- **Provider Monitoring**: Change detection and health monitoring system
- **Operations Dashboard**: Web-based management interface
- **VCP Validation**: Schema validation and transformation utilities

## Prerequisites

### Required
- Python 3.8+ with pip
- Git
- Modern web browser (for operations dashboard)

### Optional
- Docker (for containerized deployment)
- Nginx (for reverse proxy)
- PostgreSQL (for production database)

## Quick Start

### 1. Clone and Setup

```bash
git clone <repository-url>
cd voicelens-scripts

# Create Python virtual environment
python3 -m venv venv
source venv/bin/activate  # Linux/Mac
# or
# venv\Scripts\activate  # Windows

# Install dependencies
pip install -r requirements.txt
```
### 2. Create Configuration

```bash
# Create environment file
cp .env.example .env

# Edit configuration
nano .env
```
### 3. Initialize Database

```bash
# Run operations app to create database tables
python voicelens_ops_app.py &
sleep 2
kill %1  # Stop after initialization

# Or initialize monitoring database
python provider_monitoring.py --init-db
```
### 4. Run Services

```bash
# Start operations dashboard
python voicelens_ops_app.py &

# Start monitoring system (in another terminal)
python provider_monitoring.py --daemon &

# Access dashboard at http://localhost:5000
```
## Configuration

### Environment Variables

Create `.env` file with the following variables:

```bash
# Flask Configuration
SECRET_KEY=your-secret-key-here
FLASK_ENV=production
FLASK_DEBUG=false

# Database Configuration
DATABASE_URL=sqlite:///voicelens_ops.db
# or for PostgreSQL:
# DATABASE_URL=postgresql://user:password@localhost:5432/voicelens

# Monitoring Configuration  
MONITORING_INTERVAL_MINUTES=60
MONITORING_DATABASE=monitoring.db

# Notification Configuration (optional)
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
EMAIL_SMTP_HOST=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_FROM=alerts@yourdomain.com
EMAIL_PASSWORD=your-app-password

# Provider API Keys (optional, for enhanced monitoring)
RETELL_API_KEY=your-retell-api-key
BLAND_API_KEY=your-bland-api-key  
VAPI_API_KEY=your-vapi-api-key
ELEVENLABS_API_KEY=your-elevenlabs-api-key
OPENAI_API_KEY=your-openai-api-key

# Security (production)
ALLOWED_HOSTS=localhost,127.0.0.1,yourdomain.com
CORS_ORIGINS=https://yourdomain.com
```
### Advanced Configuration

For production deployments, create `config.yaml`:

```yaml
monitoring:
  interval_minutes: 30
  max_retries: 3
  timeout_seconds: 30
  
  providers:
    retell:
      enabled: true
      priority: high
      check_endpoints: ["https://api.retellai.com/health"]
      
    bland:
      enabled: true  
      priority: medium
      
    vapi:
      enabled: true
      priority: high
      
  notifications:
    slack:
      enabled: true
      channel: "#voice-ai-alerts"
      min_severity: medium
      
    email:
      enabled: true
      recipients: ["ops@company.com", "dev@company.com"]
      min_severity: high

dashboard:
  host: "0.0.0.0"
  port: 5000
  debug: false
  
  database:
    url: "postgresql://voicelens:password@localhost:5432/voicelens"
    pool_size: 10
    max_overflow: 20
    
  security:
    rate_limiting: true
    requests_per_minute: 100
    
  features:
    webhook_testing: true
    provider_comparison: true
    analytics: true
```
## Deployment Options

### Option 1: Development Deployment

For development and testing:

```bash
# Install in development mode
pip install -e .

# Run with hot reloading
export FLASK_ENV=development
export FLASK_DEBUG=true
python voicelens_ops_app.py

# Run monitoring with verbose logging  
python provider_monitoring.py --verbose --daemon
```
### Option 2: Production Deployment (systemd)

For production Linux deployments:

```bash
# Create application user
sudo useradd --system --create-home --shell /bin/false voicelens

# Install to system location
sudo mkdir -p /opt/voicelens
sudo cp -r . /opt/voicelens/
sudo chown -R voicelens:voicelens /opt/voicelens

# Install system dependencies
sudo apt update
sudo apt install -y python3-venv python3-pip nginx

# Create virtual environment
sudo -u voicelens python3 -m venv /opt/voicelens/venv
sudo -u voicelens /opt/voicelens/venv/bin/pip install -r /opt/voicelens/requirements.txt

# Create systemd service for dashboard
sudo tee /etc/systemd/system/voicelens-dashboard.service > /dev/null <<EOF
[Unit]
Description=VoiceLens Operations Dashboard
After=network.target

[Service]
Type=simple
User=voicelens
Group=voicelens
WorkingDirectory=/opt/voicelens
Environment=PATH=/opt/voicelens/venv/bin
ExecStart=/opt/voicelens/venv/bin/python voicelens_ops_app.py
Restart=always
RestartSec=10

# Environment
EnvironmentFile=/opt/voicelens/.env

# Security
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=yes
ReadWritePaths=/opt/voicelens/data

[Install]
WantedBy=multi-user.target
EOF

# Create systemd service for monitoring
sudo tee /etc/systemd/system/voicelens-monitoring.service > /dev/null <<EOF
[Unit]
Description=VoiceLens Provider Monitoring
After=network.target

[Service]
Type=simple
User=voicelens
Group=voicelens
WorkingDirectory=/opt/voicelens
Environment=PATH=/opt/voicelens/venv/bin
ExecStart=/opt/voicelens/venv/bin/python provider_monitoring.py --daemon
Restart=always
RestartSec=30

# Environment
EnvironmentFile=/opt/voicelens/.env

# Security
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=yes
ReadWritePaths=/opt/voicelens/data

[Install]
WantedBy=multi-user.target
EOF

# Enable and start services
sudo systemctl daemon-reload
sudo systemctl enable voicelens-dashboard voicelens-monitoring
sudo systemctl start voicelens-dashboard voicelens-monitoring

# Check status
sudo systemctl status voicelens-dashboard
sudo systemctl status voicelens-monitoring
```
### Option 3: Docker Deployment

Using Docker for containerized deployment:

```dockerfile
# Dockerfile
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    && rm -rf /var/lib/apt/lists/*

# Create app directory
WORKDIR /app

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash voicelens
RUN chown -R voicelens:voicelens /app
USER voicelens

# Expose ports
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/api/health || exit 1

# Start services
CMD ["python", "voicelens_ops_app.py"]
```
```yaml
# docker-compose.yml
version: '3.8'

services:
  voicelens-dashboard:
    build: .
    ports:
      - "5000:5000"
    environment:
      - DATABASE_URL=postgresql://voicelens:password@db:5432/voicelens
      - MONITORING_DATABASE=/data/monitoring.db
    volumes:
      - voicelens-data:/data
    depends_on:
      - db
    restart: unless-stopped

  voicelens-monitoring:
    build: .
    environment:
      - MONITORING_DATABASE=/data/monitoring.db
    volumes:
      - voicelens-data:/data
    command: ["python", "provider_monitoring.py", "--daemon"]
    restart: unless-stopped

  db:
    image: postgres:14
    environment:
      - POSTGRES_DB=voicelens
      - POSTGRES_USER=voicelens  
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres-data:/var/lib/postgresql/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - voicelens-dashboard
    restart: unless-stopped

volumes:
  voicelens-data:
  postgres-data:
```
```bash
# Deploy with Docker Compose
docker-compose up -d

# Check logs
docker-compose logs -f voicelens-dashboard
docker-compose logs -f voicelens-monitoring

# Scale services
docker-compose up -d --scale voicelens-dashboard=2
```
### Option 4: Cloud Deployment

#### AWS ECS

```yaml
# ecs-task-definition.json
{
  "family": "voicelens",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::account:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "voicelens-dashboard",
      "image": "your-registry/voicelens:latest",
      "portMappings": [
        {
          "containerPort": 5000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "DATABASE_URL",
          "value": "postgresql://user:pass@rds-endpoint:5432/voicelens"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/voicelens",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```
#### Kubernetes

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: voicelens-dashboard
spec:
  replicas: 2
  selector:
    matchLabels:
      app: voicelens-dashboard
  template:
    metadata:
      labels:
        app: voicelens-dashboard
    spec:
      containers:
      - name: dashboard
        image: voicelens:latest
        ports:
        - containerPort: 5000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: voicelens-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: voicelens-service
spec:
  selector:
    app: voicelens-dashboard
  ports:
  - port: 80
    targetPort: 5000
  type: LoadBalancer
```
## Nginx Configuration

For production deployments behind a reverse proxy:

```nginx
# /etc/nginx/sites-available/voicelens
server {
    listen 80;
    server_name voicelens.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name voicelens.yourdomain.com;

    ssl_certificate /etc/ssl/certs/voicelens.crt;
    ssl_certificate_key /etc/ssl/private/voicelens.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' cdn.tailwindcss.com cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' cdn.tailwindcss.com;" always;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=voicelens:10m rate=10r/s;
    limit_req zone=voicelens burst=20 nodelay;

    # Gzip compression
    gzip on;
    gzip_types text/plain application/json application/javascript text/css;

    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_redirect off;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # WebSocket support (if needed)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Static files (if serving directly)
    location /static/ {
        alias /opt/voicelens/static/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Health check endpoint (no auth)
    location /api/health {
        proxy_pass http://127.0.0.1:5000;
        access_log off;
    }
}
```
## Monitoring & Maintenance

### Health Checks

```bash
# Check service health
curl -f http://localhost:5000/api/health

# Check monitoring system
curl -f http://localhost:5000/api/monitoring/health

# Check database connectivity
python -c "from voicelens_ops_app import db; print('DB OK' if db else 'DB Failed')"
```
### Log Management

```bash
# Application logs (systemd)
sudo journalctl -u voicelens-dashboard -f
sudo journalctl -u voicelens-monitoring -f

# Rotate logs
sudo tee /etc/logrotate.d/voicelens > /dev/null <<EOF
/opt/voicelens/logs/*.log {
    daily
    missingok
    rotate 52
    compress
    delaycompress
    notifempty
    create 0644 voicelens voicelens
    postrotate
        systemctl reload voicelens-dashboard voicelens-monitoring
    endscript
}
EOF
```
### Database Maintenance

```bash
# Backup database
pg_dump voicelens > voicelens_backup_$(date +%Y%m%d).sql

# Cleanup old monitoring data (older than 90 days)
python -c "
from provider_monitoring import VoiceLensMonitoringSystem
monitor = VoiceLensMonitoringSystem()
monitor.cleanup_old_data(days=90)
print('Cleanup completed')
"

# Vacuum database
python -c "
import sqlite3
conn = sqlite3.connect('monitoring.db')
conn.execute('VACUUM')
conn.close()
print('Database vacuumed')
"
```
### Updates

```bash
# Update VoiceLens scripts
cd /opt/voicelens
git pull origin main

# Update Python dependencies  
sudo -u voicelens /opt/voicelens/venv/bin/pip install -r requirements.txt

# Restart services
sudo systemctl restart voicelens-dashboard voicelens-monitoring

# Verify deployment
curl -f http://localhost:5000/api/health
```
## Security Considerations

### Network Security
- Use HTTPS in production with proper SSL certificates
- Configure firewall to only allow necessary ports (80, 443)
- Use VPN or private networks for internal access
- Enable rate limiting and DDoS protection

### Application Security
- Change default secret keys and passwords
- Use environment variables for sensitive configuration
- Enable CORS only for trusted origins
- Implement proper authentication for admin features
- Regular security updates and dependency scanning

### Data Protection
- Encrypt sensitive data at rest
- Use hashed IP addresses for privacy
- Implement data retention policies
- Ensure GDPR/CCPA compliance for user data
- Regular database backups with encryption

## Troubleshooting

### Common Issues

1. **Port Already in Use**
```bash
# Check what's using the port
sudo lsof -i :5000
# Kill the process or change port
export FLASK_RUN_PORT=5001
```
2. **Database Connection Failed**
```bash
# Check database status
systemctl status postgresql
# Check connection string in .env file
# Verify database exists and user has permissions
```
3. **Provider Monitoring Not Working**
```bash
# Check network connectivity
curl -I https://api.retellai.com
# Verify API keys are correct
# Check monitoring logs for errors
```
4. **High Memory Usage**
```bash
# Monitor memory usage
top -p $(pgrep -f voicelens)
# Adjust monitoring intervals
# Clean up old monitoring data
```
### Support

- **Documentation**: Check this deployment guide and README files
- **Logs**: Review application and system logs for errors  
- **Issues**: Report bugs and feature requests on GitHub
- **Community**: Join the VoiceLens Discord for support

---

For additional help, consult the individual module documentation:
- `vcp_v05_schema.py` - VCP schema reference
- `provider_documentation.py` - Provider integration guide
- `provider_monitoring.py` - Monitoring system configuration
- `voicelens_ops_app.py` - Operations dashboard usage



================================================================================
📄 FILE: CONTRIBUTING.md
📝 TITLE: Contributing to VoiceLens Scripts
📊 SIZE: 3,973 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Contributing to VoiceLens Scripts

We love your input! We want to make contributing to VoiceLens Scripts as easy and transparent as possible, whether it's:

- Reporting a bug
- Discussing the current state of the code
- Submitting a fix
- Proposing new features
- Becoming a maintainer

## Development Process

We use GitHub to host code, to track issues and feature requests, as well as accept pull requests.

1. Fork the repo and create your branch from `main`
2. If you've added code that should be tested, add tests
3. If you've changed APIs, update the documentation
4. Ensure the test suite passes
5. Make sure your code follows our style guidelines
6. Issue that pull request!

## Code Style

We use automated formatting and linting:

- **Black** for code formatting
- **isort** for import sorting  
- **Ruff** for fast linting
- **mypy** for type checking

Run these before submitting:

```bash
make lint    # Run all checks
make format  # Auto-format code
```
## Testing

We use pytest for testing:

```bash
make test              # Run all tests
make test-coverage     # Run with coverage report
```
### Test Structure

- Unit tests in `tests/unit/`
- Integration tests in `tests/integration/`  
- Fixtures in `tests/fixtures/`

All tests should be fast and deterministic. Use temporary SQLite databases for integration tests.

## Commit Messages

We follow [Conventional Commits](https://www.conventionalcommits.org/):

- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `test:` - Adding/updating tests
- `chore:` - Maintenance tasks
- `perf:` - Performance improvements

Examples:
```
feat(generator): add support for multi-language scenarios
fix(classifier): handle edge case in agent role detection  
docs(readme): update installation instructions
```
## Pull Request Process

1. Update README.md or docs/ with details of changes if applicable
2. Add tests for new functionality
3. Ensure all status checks pass
4. Get approval from at least one maintainer
5. Squash and merge when ready

## Bug Reports

Use GitHub Issues with the bug report template. Include:

- Your operating system and Python version
- Exact command that caused the issue
- Full error message and stack trace
- Steps to reproduce
- Expected vs actual behavior

## Feature Requests  

Use GitHub Issues with the feature request template. Include:

- Clear description of the problem you're solving
- Proposed solution and alternatives considered
- Example usage/API if applicable
- Impact on existing functionality

## Development Setup

```bash
# Clone your fork
git clone https://github.com/YOUR-USERNAME/voicelens-scripts.git
cd voicelens-scripts

# Install in development mode
pip install -e ".[dev]"

# Install pre-commit hooks
pre-commit install

# Run tests to verify setup
make test
```
## Project Structure

```
voicelens-scripts/
├── src/voicelens_seeder/     # Main package
│   ├── cli.py                # CLI entry point
│   ├── config/               # Configuration management
│   ├── db/                   # Database schema & migrations
│   ├── generator/            # Synthetic data generation
│   ├── normalizers/          # VCP payload processing
│   ├── classifiers/          # Agent role detection
│   └── utils/               # Common utilities
├── tests/                   # Test suite
├── docs/                    # Documentation
└── examples/               # Example data & configs
```
## Performance Guidelines

- Use batch database operations where possible
- Profile performance-critical code paths
- Avoid loading large datasets into memory
- Use appropriate SQLite pragmas and indexes

## Documentation

- Update docstrings for public APIs
- Include usage examples in docstrings
- Update relevant docs/ files
- Add CLI help text for new commands

## Questions?

Feel free to open a Discussion or reach out to the maintainers. We're here to help!



================================================================================
📄 FILE: VCP_WORKING_GROUPS_STRUCTURE.md
📝 TITLE: VCP Working Groups Structure & Operations
📊 SIZE: 16,758 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VCP Working Groups Structure & Operations
**Version 1.0 | October 2025**

## Overview

This document defines the operational structure, procedures, and responsibilities of the VCP (Voice Context Protocol) working groups that govern the multi-implementation ecosystem. It provides the practical framework for coordinating development, ensuring consistency, and making technical decisions across Python, Rust, and TypeScript implementations.

## 1. Organizational Chart

```mermaid
graph TD
    A[VCP Technical Steering Committee] --> B[VCP Schema Working Group]
    A --> C[Provider Integration Council]
    A --> D[Security Response Team]
    
    B --> E[Python Implementation WG]
    B --> F[Rust Implementation WG]  
    B --> G[TypeScript Implementation WG]
    
    H[Community] --> A
    H --> B
    H --> C
    
    I[Provider Representatives] --> C
    J[End Users] --> A
    K[Contributors] --> E
    K --> F
    K --> G
```
## 2. VCP Technical Steering Committee (TSC)

### 2.1 Charter & Responsibilities
The TSC provides strategic direction, conflict resolution, and final authority on breaking changes and governance decisions.

#### Core Responsibilities:
- **Strategic Direction**: VCP roadmap, major version planning, foundation transition
- **Governance**: Charter amendments, working group oversight, conflict resolution
- **Breaking Changes**: Final approval for VCP major version releases
- **Community Health**: Maintainer sustainability, contributor recognition, code of conduct
- **Legal & IP**: Trademark management, patent policy, licensing decisions

#### Decision-Making Authority:
- ✅ VCP major version releases (0.5 → 1.0)
- ✅ Governance charter changes
- ✅ Working group creation/dissolution  
- ✅ Conflict escalation final decisions
- ✅ Foundation transition approval
- ✅ Security vulnerability response coordination

### 2.2 Composition & Selection

#### Members (7 total):
1. **VCP Specification Lead** (1)
   - Role: Owns canonical schema, coordinates versions
   - Selection: Community nomination + TSC approval
   - Term: 2 years, renewable

2. **Implementation Leads** (3)
   - Roles: Python, Rust, TypeScript implementation maintainers
   - Selection: Implementation working group nomination
   - Term: 2 years, renewable

3. **Community Representatives** (2)
   - Roles: Provider integrators, end-user advocates
   - Selection: Community election (annual)
   - Term: 1 year, renewable (max 3 terms)

4. **Security Officer** (1)
   - Role: Security implications, vulnerability management
   - Selection: TSC appointment
   - Term: 2 years, renewable

#### Selection Process:
```mermaid
graph LR
    A[Nominations Open] --> B[Community Review]
    B --> C[Working Group Input]
    C --> D[TSC Vote]
    D --> E[Public Announcement]
```
### 2.3 Meeting Operations

#### Schedule:
- **Regular Meetings**: First Tuesday of each month, 2:00 PM UTC
- **Emergency Sessions**: Within 48 hours of critical issues
- **Annual Planning**: Full-day strategic planning session

#### Meeting Structure:
1. **Opening** (5 min)
   - Attendance, agenda review
2. **Implementation Reports** (15 min)
   - Status updates from each implementation
3. **Working Group Reports** (15 min)
   - Schema WG, Provider Council updates
4. **Decision Items** (20 min)
   - VIPs requiring TSC approval
5. **Discussion Items** (15 min)
   - Strategic planning, community issues
6. **Closing** (5 min)
   - Action items, next meeting

#### Decision Process:
- **Quorum**: 5 of 7 members required
- **Consensus First**: Attempt consensus on all decisions
- **Voting**: Simple majority (4/7) if consensus not reached
- **Vetoes**: Security Officer has security veto power
- **Records**: All decisions recorded as ADRs (Architecture Decision Records)

## 3. VCP Schema Working Group (SWG)

### 3.1 Purpose & Authority
Technical oversight of VCP specification evolution, ensuring consistency and backward compatibility across all implementations.

#### Core Responsibilities:
- **Schema Evolution**: Review and approve VIPs (VCP Improvement Proposals)
- **Version Management**: Coordinate version releases, migration paths
- **Compatibility**: Ensure cross-implementation compatibility
- **Extension Registry**: Manage VCP extension namespace and approval
- **Technical Standards**: Define implementation requirements and quality gates

#### Decision-Making Authority:
- ✅ VIP approval (non-breaking changes)
- ✅ Extension registry additions
- ✅ Implementation compatibility requirements
- ✅ Technical standard definitions
- ⚠️ Breaking changes (recommend to TSC)

### 3.2 Composition

#### Core Members:
- **Chair**: Elected annually by SWG members
- **Implementation Leads**: Python, Rust, TypeScript leads (ex-officio)
- **Provider Integration Specialists** (2-3): Experts in provider mappings
- **Community Contributors**: Active contributors (as needed)

#### Rotating Participants:
- **Subject Matter Experts**: Invited for specific topics
- **Provider Representatives**: For provider-specific discussions
- **Security Specialist**: For security-related VIPs

### 3.3 VIP (VCP Improvement Proposal) Process

#### VIP Lifecycle:
```mermaid
graph TD
    A[Community Idea] --> B[GitHub Discussion]
    B --> C[Draft VIP]
    C --> D[SWG Review]
    D --> E[Implementation Feedback]
    E --> F[Community Comment]
    F --> G[Final Review]
    G --> H{Breaking Change?}
    H -->|Yes| I[TSC Approval]
    H -->|No| J[SWG Approval]
    I --> K[Implementation Phase]
    J --> K
    K --> L[Release]
```
#### VIP Template:
```markdown
# VIP-XXXX: [Title]

## Summary
Brief description of the proposal

## Motivation  
Why is this change needed?

## Detailed Design
Technical specification

## Rationale and Alternatives
Why this approach over alternatives?

## Backwards Compatibility
Impact on existing implementations

## Reference Implementation
Code examples or pseudo-code

## Unresolved Questions
Open issues for discussion
```
### 3.4 Meeting Operations

#### Schedule:
- **Bi-weekly**: Every other Wednesday, 3:00 PM UTC
- **VIP Reviews**: Special sessions as needed
- **Implementation Sync**: Monthly with all implementation WGs

#### Typical Agenda:
1. **VIP Review Queue** (30 min)
2. **Implementation Status** (15 min)
3. **Compatibility Issues** (10 min)
4. **New Business** (5 min)

## 4. Implementation Working Groups

### 4.1 Python Implementation Working Group

#### Focus Areas:
- **Production Maturity**: Enterprise deployment patterns
- **Provider Integrations**: Comprehensive provider support
- **Migration Tools**: Version upgrade/downgrade utilities
- **Performance**: Production-scale optimization

#### Regular Activities:
- **Code Reviews**: All Python implementation changes
- **Provider Testing**: Validation with real provider webhooks
- **Performance Monitoring**: Benchmark maintenance
- **Documentation**: Python-specific guides and examples

#### Meeting Schedule:
- **Bi-weekly**: Alternates with other implementation WGs
- **Provider Sync**: Monthly with Provider Integration Council

### 4.2 Rust Implementation Working Group  

#### Focus Areas:
- **Performance Leadership**: Rust as performance baseline
- **Memory Safety**: Leverage Rust's safety guarantees
- **Type System**: Compile-time VCP validation
- **WebAssembly**: Browser and edge deployment targets

#### Regular Activities:
- **Performance Benchmarking**: Maintain performance baselines
- **Security Audits**: Memory safety validation
- **Type System Validation**: Ensure compile-time correctness
- **WASM Optimization**: Browser performance optimization

#### Meeting Schedule:
- **Bi-weekly**: Alternates with other implementation WGs
- **Performance Reviews**: Monthly performance analysis

### 4.3 TypeScript Implementation Working Group

#### Focus Areas:
- **Developer Experience**: Best-in-class TypeScript experience
- **Web Platform**: Browser and Node.js compatibility
- **Ecosystem Integration**: NPM ecosystem integration
- **Frontend/Backend**: Full-stack TypeScript support

#### Regular Activities:
- **DX Optimization**: Developer experience improvements
- **Browser Testing**: Cross-browser compatibility validation
- **NPM Maintenance**: Package publishing and versioning
- **Framework Integration**: React, Vue, Angular compatibility

#### Meeting Schedule:
- **Bi-weekly**: Alternates with other implementation WGs  
- **DX Reviews**: Monthly developer experience assessment

## 5. Provider Integration Council (PIC)

### 5.1 Purpose
Represent voice AI provider interests and coordinate provider-specific integration requirements.

#### Responsibilities:
- **Provider Mapping Standards**: Define provider webhook mapping requirements
- **New Provider Onboarding**: Guide new provider integrations
- **Breaking Change Assessment**: Evaluate impact on provider integrations
- **Compliance Testing**: Validate provider compliance with VCP standards

### 5.2 Composition

#### Provider Representatives:
- **Retell AI**: Technical integration lead
- **Vapi**: Technical integration lead  
- **Bland AI**: Technical integration lead
- **ElevenLabs**: Technical integration lead
- **OpenAI**: Realtime API integration lead
- **Assistable AI**: Technical integration lead

#### Community Representatives:
- **Independent Integrators** (2): Agency/consultancy representatives
- **End-User Advocates** (1): Large-scale deployment representative

### 5.3 Activities

#### Regular:
- **Provider Status Updates**: Monthly integration status
- **New Provider Evaluation**: Quarterly new provider assessment
- **Breaking Change Impact**: Assessment of VCP changes on providers
- **Compliance Monitoring**: Provider VCP compliance tracking

#### Ad-Hoc:
- **Emergency Provider Changes**: Rapid response to provider API changes
- **Integration Support**: Help new providers implement VCP
- **Conflict Resolution**: Provider-specific implementation conflicts

## 6. Security Response Team

### 6.1 Charter
Coordinate security vulnerability response across all VCP implementations and provide security guidance.

#### Responsibilities:
- **Vulnerability Assessment**: Evaluate reported security issues
- **Coordinated Response**: Manage disclosure and patching across implementations
- **Security Standards**: Define security requirements for VCP implementations
- **Threat Modeling**: Ongoing security threat analysis

### 6.2 Composition
- **Security Officer** (TSC member, lead)
- **Implementation Security Contacts** (1 per implementation)
- **External Security Advisor** (as needed)

### 6.3 Response Process
```mermaid
graph TD
    A[Vulnerability Report] --> B[48h Assessment]
    B --> C{Severity Level}
    C -->|Critical| D[Immediate Response]
    C -->|High| E[7-day Response]
    C -->|Medium| F[30-day Response]
    D --> G[Coordinated Patch]
    E --> G
    F --> G
    G --> H[Public Disclosure]
```
## 7. Communication & Coordination

### 7.1 Communication Channels

#### Primary:
- **GitHub Discussions**: Technical discussions, VIPs
- **Discord Server**: Real-time community communication
- **Mailing Lists**: Official announcements, security reports

#### Working Group Specific:
- **Slack Channels**: Internal working group coordination
- **Video Calls**: Regular working group meetings
- **Shared Documents**: Meeting notes, decision records

### 7.2 Information Flow

#### Upward (to TSC):
- **Monthly Reports**: Each WG provides status update
- **Escalations**: Technical conflicts, resource needs
- **Recommendations**: Breaking changes, strategic decisions

#### Downward (from TSC):
- **Strategic Direction**: Roadmap updates, priorities
- **Decisions**: ADRs, policy changes
- **Resources**: Funding, infrastructure, support

#### Lateral (between WGs):
- **Coordination**: Cross-WG initiatives, dependencies
- **Information Sharing**: Best practices, lessons learned
- **Joint Initiatives**: Cross-implementation projects

### 7.3 Decision Records

#### Architecture Decision Records (ADRs):
```markdown
# ADR-XXXX: [Title]

## Status
[Proposed | Accepted | Deprecated | Superseded]

## Context
What is the issue we're addressing?

## Decision  
What is the change we're making?

## Consequences
What becomes easier/harder to do?
```
#### Decision Tracking:
- **Repository**: Central ADR repository
- **Numbering**: Sequential ADR numbers
- **Linking**: VIPs reference related ADRs
- **Updates**: ADRs updated when decisions change

## 8. Conflict Resolution

### 8.1 Escalation Path
```mermaid
graph TD
    A[Technical Disagreement] --> B[Implementation WG]
    B --> C[Schema WG]
    C --> D[TSC]
    D --> E[Resolution]
    
    F[Community Issue] --> G[Community Moderators]
    G --> H[TSC]
    H --> E
    
    I[Security Issue] --> J[Security Response Team]
    J --> E
```
### 8.2 Resolution Process

#### Level 1: Working Group Resolution
- **Timeline**: 14 days for resolution attempt
- **Process**: Discussion, compromise, consensus building
- **Outcome**: Decision or escalation to next level

#### Level 2: Schema Working Group
- **Timeline**: 14 days for resolution attempt  
- **Process**: Technical review, implementation impact assessment
- **Outcome**: Technical recommendation or TSC escalation

#### Level 3: TSC Final Decision
- **Timeline**: 30 days maximum
- **Process**: Full review, community input, formal vote
- **Outcome**: Binding decision with implementation timeline

## 9. Performance & Accountability

### 9.1 Working Group Metrics

#### Participation:
- **Meeting Attendance**: >80% for core members
- **Response Time**: <48 hours for urgent issues
- **Deliverable Completion**: >90% of committed deliverables

#### Effectiveness:
- **Decision Velocity**: Average time from VIP to implementation
- **Quality Gates**: % of releases meeting quality standards
- **Community Satisfaction**: Quarterly community surveys

### 9.2 Working Group Health

#### Signs of Healthy WG:
- ✅ Regular meeting attendance
- ✅ Active GitHub/Discord participation
- ✅ Timely decision making
- ✅ Clear deliverable completion
- ✅ Positive community feedback

#### Signs of At-Risk WG:
- ⚠️ Low meeting attendance (<50%)
- ⚠️ Delayed decisions (>30 days average)
- ⚠️ Deliverable slippage (>30%)
- ⚠️ Community complaints
- ⚠️ Member burnout indicators

### 9.3 Remediation Process

#### Performance Issues:
1. **Assessment**: TSC reviews WG performance
2. **Discussion**: Direct conversation with WG lead
3. **Support**: Additional resources, mentoring, restructuring
4. **Timeline**: 90-day improvement plan
5. **Evaluation**: Success metrics and next steps

## 10. Annual Planning & Review

### 10.1 Annual Planning Process

#### Q4 Planning Cycle:
- **October**: Community feedback collection
- **November**: Working group planning sessions  
- **December**: TSC strategic planning retreat

#### Planning Inputs:
- **Community Survey**: Annual community needs assessment
- **Provider Feedback**: Provider integration challenges and requests
- **Implementation Status**: Technical debt, performance gaps
- **Industry Trends**: Voice AI market evolution

### 10.2 Annual Review

#### Review Elements:
- **Goal Achievement**: Previous year's objective completion
- **Process Effectiveness**: Working group operations assessment
- **Community Growth**: Contributor and user growth analysis
- **Technical Progress**: Implementation maturity and capability growth

#### Outcomes:
- **Annual Report**: Public progress report
- **Process Improvements**: WG operational refinements
- **Strategic Adjustments**: Roadmap and priority updates
- **Resource Allocation**: Next year's resource planning

---

## Conclusion

This working group structure provides VCP with the organizational foundation necessary to coordinate complex multi-implementation development while maintaining technical excellence and community engagement. The framework balances formal process with practical flexibility, enabling VCP to evolve as a mature, well-governed open standard.

**Key Success Factors**:
- Clear roles and responsibilities across all working groups
- Transparent decision-making processes with appropriate escalation
- Regular coordination and communication between groups
- Performance accountability and continuous improvement
- Community engagement and feedback integration

**Next Steps**:
1. **Working Group Formation**: Recruit and formally establish each working group
2. **Process Implementation**: Begin regular meeting cadences and procedures
3. **Tool Setup**: Establish communication channels and collaboration tools
4. **Community Launch**: Public announcement of governance structure
5. **First Quarter Operations**: Execute first full quarter under new structure

---

*This document evolves based on working group experience and community feedback.*



================================================================================
📄 FILE: USAGE.md
📝 TITLE: VoiceLens Scripts Usage Guide
📊 SIZE: 7,009 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VoiceLens Scripts Usage Guide

## Quick Start

### Installation

1. Clone the repository:
```bash
git clone https://github.com/prompted365/voicelens-scripts.git
cd voicelens-scripts
```
2. Create a virtual environment and install dependencies:
```bash
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -e .
```
## Basic Usage

### Generate Baseline Examples

Generate the 8 baseline HVAC examples matching your original curl commands:

```bash
python -m voicelens_seeder.cli generate baseline
```
This creates 8 reproducible VCP 0.3 payloads in the `baseline_examples/` directory:

- `hvac_001_booked_service_retell.json` - After-hours AC repair booking
- `hvac_002_live_transfer_vapi.json` - Live transfer to dispatcher
- `hvac_003_scheduled_callback_bland.json` - Callback window scheduled
- `hvac_004_quote_requested_retell.json` - Furnace install quote
- `hvac_005_out_of_service_area_vapi.json` - Out of service area
- `hvac_006_spam_filtered_retell.json` - Spam/non-lead filtered
- `hvac_007_no_show_cancel_bland.json` - No-show/cancellation
- `hvac_008_emergency_service_retell.json` - Emergency heat out

### Generate Synthetic Conversations

Generate a larger dataset of synthetic conversations:

```bash
# Generate 50 conversations over the past 30 days
python -m voicelens_seeder.cli generate conversations --count 50

# Generate for a specific provider
python -m voicelens_seeder.cli generate conversations --count 25 --provider retell

# Generate with reproducible seed
python -m voicelens_seeder.cli generate conversations --count 100 --seed 12345

# Generate to a specific directory
python -m voicelens_seeder.cli generate conversations --count 20 --out ./my_data
```
## Advanced Usage

### Command Line Options

```bash
# Full conversation generation options
python -m voicelens_seeder.cli generate conversations \
  --count 200 \
  --provider all \
  --start-days-ago 60 \
  --vcp-mode gtm \
  --seed 42 \
  --out ./generated_data

# Baseline generation options  
python -m voicelens_seeder.cli generate baseline \
  --seed 42 \
  --out ./baseline_data
```
### Provider Options

- `retell` - Retell AI conversations only
- `vapi` - VAPI conversations only  
- `bland` - Bland AI conversations only
- `all` - Mix of all providers (default)

### VCP Mode Options

- `gtm` - Streamlined GTM mode (default)
- `full` - Complete VCP 0.3 compliance mode

## Programming Interface

### Using the Generator Directly

```python
from datetime import datetime, timezone, timedelta
from voicelens_seeder.generator.synthetic import VCPSyntheticGenerator
from voicelens_seeder.normalizers.vcp import Provider
from voicelens_seeder.generator.hvac_scenarios import HVACScenario

# Initialize generator
generator = VCPSyntheticGenerator(seed=42)

# Generate baseline examples
baseline = generator.generate_baseline_examples()
print(f"Generated {len(baseline)} baseline examples")

# Generate time series data
end_time = datetime.now(timezone.utc)
start_time = end_time - timedelta(days=7)

calls = list(generator.generate_call_batch(
    count=100,
    start_date=start_time,
    end_date=end_time,
    providers=[Provider.RETELL, Provider.VAPI]
))

# Save as JSON files
from pathlib import Path
output_dir = Path("./my_synthetic_data")
generator.save_examples_as_json(calls, output_dir)

# Access individual payloads
for call in calls:
    print(f"Call ID: {call.call_id}")
    print(f"Provider: {call.vcp_payload.call.provider}")
    print(f"Scenario: {call.vcp_payload.custom.outcome_hint}")
    print(f"Duration: {call.vcp_payload.call.duration_sec}s")
    print(f"Status: {call.vcp_payload.outcomes.objective.status}")
    print("---")
```
### Scenario Types

The generator supports these HVAC scenarios:

- `BOOKED_SERVICE` - Successful service appointment booking
- `LIVE_TRANSFER` - Transfer to human dispatcher
- `SCHEDULED_CALLBACK` - Callback window scheduled
- `QUOTE_REQUESTED` - Installation or repair quote
- `OUT_OF_SERVICE_AREA` - Outside service coverage
- `SPAM_FILTERED` - Non-lead/spam call filtered
- `NO_SHOW_CANCEL` - Appointment cancellation
- `EMERGENCY_SERVICE` - Emergency HVAC service

## Data Format

All generated data follows the VCP 0.3 standard with:

- **Call Information**: Provider, timing, capabilities, success criteria
- **Outcomes**: Perceived sentiment, objective metrics, perception gaps
- **Artifacts**: Recording URLs, transcript refs, provider payloads  
- **Custom Fields**: Provider-specific data, synthetic markers
- **Audit Trail**: Processing timestamps, schema versioning

### Example Payload Structure

```json
{
  "call_id": "uuid",
  "vcp_version": "0.3",
  "vcp_payload": {
    "call": { /* call info */ },
    "outcomes": {
      "perceived": [{ /* sentiment analysis */ }],
      "objective": { /* metrics and status */ },
      "perception_gap": { /* gap analysis */ }
    },
    "artifacts": { /* URLs and refs */ },
    "custom": { 
      "synthetic": true,
      "outcome_hint": "booked_service"
    },
    "audit": { /* processing trail */ }
  }
}
```
## Integration

### Testing VoiceLens Endpoints

Use generated data to test your VoiceLens endpoints:

```bash
# Generate test data
python -m voicelens_seeder.cli generate baseline --out ./test_data

# Send to endpoint (example)
for file in test_data/*.json; do
  curl -X POST https://your-voicelens-endpoint.com/conversations \
    -H "Content-Type: application/json" \
    -d @"$file"
done
```
### Dashboard Development

Load synthetic data for dashboard prototyping:

```python
import json
from pathlib import Path

# Load all generated conversations
data_dir = Path("./synthetic_data")
conversations = []

for json_file in data_dir.glob("*.json"):
    with open(json_file) as f:
        conversations.append(json.load(f))

# Extract metrics for dashboard
metrics = []
for conv in conversations:
    payload = conv["vcp_payload"]
    metrics.append({
        "provider": payload["call"]["provider"],
        "duration": payload["call"]["duration_sec"],
        "status": payload["outcomes"]["objective"]["status"],
        "sentiment": payload["outcomes"]["perceived"][0]["sentiment"]["score"],
        "value": payload["outcomes"]["objective"]["metrics"]["estimated_value_usd"],
        "scenario": payload["custom"]["outcome_hint"]
    })

# Now use metrics for charts, tables, etc.
```
## Troubleshooting

### Common Issues

1. **ModuleNotFoundError**: Make sure you've activated the virtual environment and installed with `pip install -e .`

2. **Permission errors**: Ensure you have write permissions to the output directory

3. **Invalid provider**: Use one of: retell, vapi, bland, all

4. **Memory issues with large batches**: Generate in smaller chunks if creating thousands of conversations

### Getting Help

```bash
# View all available commands
python -m voicelens_seeder.cli --help

# Get help for specific commands
python -m voicelens_seeder.cli generate --help
python -m voicelens_seeder.cli generate baseline --help
```



================================================================================
📄 FILE: VCP_GOVERNANCE_EXECUTIVE_SUMMARY.md
📝 TITLE: VCP Governance Executive Summary & Implementation Roadmap
📊 SIZE: 12,666 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VCP Governance Executive Summary & Implementation Roadmap
**Version 1.0 | October 2025**

## Executive Summary

Your Voice Context Protocol (VCP) ecosystem has reached a critical maturity point that demands professional, centralized governance. With production deployments across **Python** (voicelens-scripts), **Rust** (voicelens-vcp-rust), and **TypeScript** (Voice Lens Platform) implementations, you need structured coordination to maintain consistency, drive innovation, and establish VCP as the definitive voice AI interoperability standard.

### Current State Assessment

#### ✅ Strengths
- **Proven VCP v0.5 Schema**: Comprehensive, production-tested specification
- **Multi-Language Implementations**: Python (mature), Rust (high-performance), TypeScript (web-focused)  
- **Provider Integration**: Support for 6+ major voice AI providers (Retell, Vapi, Bland, ElevenLabs, OpenAI, Assistable)
- **Comprehensive Documentation**: Complete technical specifications and integration guides
- **Real Production Usage**: Battle-tested with actual voice AI deployments

#### 🔧 Governance Gaps
- **No Formal Decision Process**: Schema changes lack coordinated approval process
- **Implementation Drift Risk**: No systematic consistency validation across languages
- **Provider Coordination**: Ad-hoc provider relationship management
- **Version Management**: Informal versioning without release coordination
- **Community Structure**: No clear contribution pathways or maintainer roles

### Governance Solution Overview

#### 🎯 Three-Tier Governance Model

```mermaid
graph TD
    A[VCP Technical Steering Committee] --> B[Strategic Direction & Breaking Changes]
    C[VCP Schema Working Group] --> D[Technical Standards & VIPs]
    E[Implementation Working Groups] --> F[Language-Specific Development]
    
    A --> C
    C --> E
    
    G[Provider Integration Council] --> A
    H[Security Response Team] --> A
```
#### 🔄 VIP (VCP Improvement Proposal) Process
- **Structured RFC Process**: Formal technical change proposals
- **Multi-Implementation Review**: All languages evaluate feasibility
- **Community Input**: Public comment periods
- **Coordinated Implementation**: Synchronized releases across implementations

#### 📋 Implementation Consistency Framework
- **Canonical Test Suite**: Cross-implementation compatibility validation  
- **Provider Mapping Registry**: Centralized provider integration definitions
- **Performance Benchmarking**: Consistent performance standards
- **Security Standards**: Coordinated vulnerability response

## Strategic Benefits

### 🚀 Technical Excellence
- **Zero Compatibility Regressions**: Systematic testing prevents implementation drift
- **Faster Innovation**: Clear processes accelerate feature development
- **Quality Assurance**: Formal quality gates ensure production readiness
- **Security Coordination**: Unified security response across implementations

### 🤝 Industry Leadership  
- **Provider Confidence**: Professional governance builds provider trust
- **Standard Recognition**: Foundation-track governance enables industry standard status
- **Community Growth**: Clear contribution pathways attract developers
- **Enterprise Adoption**: Governance maturity enables enterprise sales

### 💰 Business Value
- **Reduced Risk**: Professional governance reduces technical and business risk
- **Market Position**: Industry-standard governance differentiates VCP
- **Partnership Enablement**: Mature governance enables strategic partnerships
- **Investment Readiness**: Professional structure supports funding/M&A scenarios

## Implementation Roadmap

### Phase 1: Foundation (Q4 2025) - **IMMEDIATE**

#### Week 1-2: Governance Launch
- ✅ **Charter Ratification**: Formalize governance charter (COMPLETED)
- ✅ **Working Group Formation**: Recruit initial working group members
- 🔄 **Communication Setup**: Establish Discord, mailing lists, GitHub discussions
- 🔄 **Tool Configuration**: Set up meeting scheduling, documentation systems

#### Week 3-4: Process Implementation  
- 📋 **VIP Process**: Create VIP repository and templates
- 📋 **Testing Framework**: Set up compatibility test infrastructure
- 📋 **CI/CD Pipeline**: Establish cross-implementation testing
- 📋 **Documentation Site**: Central documentation hub

#### Success Criteria:
- All working groups have initial members
- First VIP proposal submitted and reviewed
- Cross-implementation tests running in CI
- Community announcement published

### Phase 2: Harmonization (Q1 2026)

#### Month 1: Standards Implementation
- 🔄 **Compatibility Test Suite**: Complete provider mapping tests
- 🔄 **Performance Baselines**: Establish benchmarks across implementations
- 🔄 **Provider Registry**: Formalize provider integration standards
- 🔄 **Security Framework**: Implement coordinated vulnerability response

#### Month 2: Process Maturation
- 📋 **First VIP Implementation**: Complete first cross-implementation VIP
- 📋 **Provider Council**: Formal provider representative structure
- 📋 **Community Feedback**: First quarterly community survey
- 📋 **Quality Metrics**: Establish working group performance metrics

#### Month 3: Release Coordination
- 📋 **Synchronized Release**: First coordinated release across implementations
- 📋 **Migration Testing**: Version upgrade/downgrade validation
- 📋 **Documentation Completion**: Full API documentation consistency
- 📋 **Community Growth**: First community contributors outside core team

#### Success Criteria:
- 100% compatibility tests passing across implementations
- First coordinated release completed within 48-hour window
- 5+ new community contributors
- Provider compliance program operational

### Phase 3: Optimization (Q2 2026)

#### Advanced Features
- 📋 **Performance Optimization**: Language-specific performance improvements
- 📋 **Security Enhancements**: Advanced security features implementation
- 📋 **Developer Experience**: Tooling improvements across implementations
- 📋 **Extension Ecosystem**: First third-party VCP extensions

#### Community Growth
- 📋 **Conference Presence**: VCP presentations at major conferences
- 📋 **Training Materials**: Comprehensive VCP training resources
- 📋 **Partner Program**: Formal integrator/consultant program
- 📋 **Awards Program**: Recognition for contributors and implementers

#### Success Criteria:
- 50+ community contributors
- 10+ production VCP deployments beyond core team
- Performance improvements >20% across implementations
- First third-party VCP extensions published

### Phase 4: Foundation Transition (Q3-Q4 2026)

#### Foundation Evaluation
- 📋 **Adoption Assessment**: Evaluate against foundation criteria
- 📋 **Foundation Research**: Research CNCF, Linux Foundation options
- 📋 **Community Readiness**: Assess community support for foundation move
- 📋 **Legal Preparation**: IP transfer and trademark considerations

#### Industry Recognition
- 📋 **Standards Body Engagement**: Engage with relevant standards organizations
- 📋 **Industry Partnerships**: Strategic partnerships with major players
- 📋 **Certification Program**: VCP implementation certification
- 📋 **Training Certification**: VCP developer certification program

#### Success Criteria:
- 1000+ production VCP deployments
- 100+ regular contributors
- 20+ VCP-certified implementations
- Foundation transition decision made

## Key Success Metrics

### Technical Metrics
| Metric | Q4 2025 Target | Q2 2026 Target | Q4 2026 Target |
|--------|----------------|----------------|----------------|
| Cross-impl compatibility | 95% | 99% | 100% |
| Test coverage | 80% | 90% | 95% |
| Performance variance | <10% | <5% | <3% |
| Security response time | 7 days | 48 hours | 24 hours |

### Adoption Metrics  
| Metric | Q4 2025 Target | Q2 2026 Target | Q4 2026 Target |
|--------|----------------|----------------|----------------|
| Active implementations | 3 | 3 | 3+ |
| Production deployments | 10 | 50 | 1000+ |
| Provider integrations | 6 | 10 | 15+ |
| Community contributors | 10 | 50 | 100+ |

### Quality Metrics
| Metric | Q4 2025 Target | Q2 2026 Target | Q4 2026 Target |
|--------|----------------|----------------|----------------|
| Open bugs | <20 | <10 | <5 |
| Documentation coverage | 90% | 95% | 100% |
| Migration success rate | 90% | 95% | 99% |
| Community satisfaction | 4.0/5 | 4.2/5 | 4.5/5 |

## Resource Requirements

### Q4 2025 - Foundation Phase
- **Time Commitment**: 10-15 hours/week for governance setup
- **Infrastructure**: GitHub, Discord, documentation hosting (~$100/month)
- **Community Management**: Part-time community management support
- **Legal**: Trademark filing and IP review (~$5,000 one-time)

### Q1 2026 - Harmonization Phase  
- **Development Time**: 20-25 hours/week across all implementations
- **Testing Infrastructure**: CI/CD expansion (~$500/month)
- **Community Events**: Conference presence and meetups (~$10,000/quarter)
- **Documentation**: Technical writing support (contract/part-time)

### Q2-Q4 2026 - Growth & Foundation Phase
- **Full-time Roles**: Consider full-time community manager/DevRel
- **Foundation Costs**: Foundation membership and transition (~$50,000/year)
- **Legal & Compliance**: Ongoing IP management (~$2,000/month)
- **Events & Marketing**: Conference sponsorships and events (~$50,000/year)

## Risk Mitigation

### Technical Risks
- **Implementation Drift**: ✅ Mitigated by compatibility test suite
- **Performance Regression**: ✅ Mitigated by automated benchmarking
- **Security Vulnerabilities**: ✅ Mitigated by coordinated security response
- **Provider API Changes**: ✅ Mitigated by provider council engagement

### Business Risks
- **Community Fragmentation**: ✅ Mitigated by transparent governance
- **Provider Resistance**: ✅ Mitigated by provider council representation
- **Resource Constraints**: ✅ Mitigated by phased implementation approach
- **Market Competition**: ✅ Mitigated by first-mover advantage and quality

### Operational Risks
- **Governance Overhead**: ✅ Mitigated by lightweight process design
- **Decision Delays**: ✅ Mitigated by clear escalation paths
- **Maintainer Burnout**: ✅ Mitigated by workload distribution
- **Tool Complexity**: ✅ Mitigated by proven tool choices

## Call to Action

### Immediate Next Steps (This Week)
1. **Review & Approve Charter**: Final review of governance documents
2. **Recruit Initial Members**: Identify working group participants  
3. **Set Up Infrastructure**: Discord server, GitHub discussions, mailing lists
4. **Create Project Boards**: Track governance implementation progress
5. **Community Announcement**: Public launch of governance structure

### Success Dependencies
- **Leadership Commitment**: Consistent time investment in governance
- **Community Engagement**: Active participation from implementation teams  
- **Provider Buy-in**: Support from major voice AI providers
- **Quality Standards**: Unwavering commitment to technical excellence
- **Long-term Vision**: Maintain focus on industry standard goal

## Conclusion

VCP stands at a pivotal moment. Your technical foundation is solid, your implementations are mature, and your provider ecosystem is established. Professional governance is the missing piece that will transform VCP from a successful project into an industry standard.

The governance framework outlined here leverages proven patterns from successful open source projects while addressing the unique challenges of multi-implementation coordination. The phased approach minimizes risk while establishing the organizational foundation necessary for long-term success.

**The next 90 days are critical.** Implementing this governance structure now positions VCP to capitalize on the growing voice AI market and establish lasting industry leadership.

---

## Appendix: Governance Documents

1. **[VCP Governance Charter]((./VCP_GOVERNANCE_CHARTER.md))**: Complete governance framework and decision-making processes
2. **[Implementation Consistency Framework]((./VCP_IMPLEMENTATION_CONSISTENCY_FRAMEWORK.md))**: Technical processes for multi-implementation coordination  
3. **[Working Groups Structure]((./VCP_WORKING_GROUPS_STRUCTURE.md))**: Operational procedures for working groups and committees

---

**Effective Date**: October 14, 2025  
**Review Date**: January 14, 2026  
**Status**: Ready for Implementation

*This executive summary serves as the actionable roadmap for establishing professional VCP governance. Success requires immediate action and sustained commitment to the outlined processes and timelines.*



================================================================================
📄 FILE: VCP_V0.5_CHANGELOG.md
📝 TITLE: Voice Context Protocol (VCP) v0.5 Changelog & Migration Guide
📊 SIZE: 10,346 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Voice Context Protocol (VCP) v0.5 Changelog & Migration Guide

## Overview

VCP v0.5 represents a comprehensive consolidation and enhancement of the Voice Context Protocol, merging the real v0.3 production schema with the v0.4 extensions into a unified, production-ready specification.

**Important**: The v0.4 version was discovered to be an incomplete stub implementation. VCP v0.5 properly extends the actual v0.3 schema with all intended v0.4 features.

## Version History

- **v0.3**: Production schema (actual baseline)
- **v0.4**: Incomplete stub implementation (deprecated)
- **v0.5**: Comprehensive schema merging v0.3 + intended v0.4 features (**CURRENT**)
- **v1.0**: Future locked specification (governance-controlled)

## Key Changes in v0.5

### ✅ **Retained from v0.3**
All existing v0.3 structures are preserved with backward compatibility:
- `call` structure with `call_id`, `session_id`, `provider`, timestamps
- `model_selection` with `policy_id`, `resolved_at`, `roles`
- `outcomes` with `perceived`, `objective`, `perception_gap`, `model_outcome_attribution`
- `hcr` (Human Readable Context) structure
- `artifacts` with provider payload references
- `custom.provider_specific` for provider-specific data
- `audit` information with `received_at` and `schema_version`

### 🆕 **New in v0.5**

#### Enhanced Call Information
- **Session Correlation**:
  - `parent_session_id`: Hierarchical session grouping
  - `correlation_id`: Cross-system correlation tracking
- **Channel & Context**:
  - `channel`: Communication channel type (phone, web, mobile, embed, api, websocket)
  - `caller_id`: Anonymized caller identification
  - `geographic_region`: Geographic context
- **Enhanced Capabilities**:
  - Upgraded from simple strings to rich `CapabilityInvocation` objects
  - Tracks `capability_type`, `invoked_at`, `duration_ms`, `success`, `error_message`, `metadata`
  - Backward compatible with v0.3 string format

#### Model Selection Enhancements
- **Selection Strategy**: `selection_strategy` field for tracking optimization approach
- **Timing**: `total_selection_time_ms` and per-role `selection_time_ms` 
- **Enhanced Telemetry**: Cost tracking with `cost_per_token` and `availability` metrics
- **Fallback Tracking**: `fallback_used` flag for model fallback scenarios

#### Comprehensive Outcomes
- **User Satisfaction**: `user_satisfaction_score` (0-1 scale)
- **Business Impact**: Revenue attribution, CLV impact, conversion probability
- **Enhanced Attribution**: Token processing and cost tracking per model role
- **Assessment Timing**: `assessment_time_ms` for performance monitoring

#### Human-Readable Context (HCR) Extensions
- **Detailed Summary**: Full interaction summary beyond key points
- **Recommendations**: AI-generated improvement suggestions
- **Alert Levels**: info/warning/critical classification for operational alerts

#### Artifacts & References
- **System Integration**: `system_logs_ref` for debugging
- **Debug Artifacts**: Structured debug information references
- **Compliance Records**: GDPR, CCPA, retention schedule references

#### Consent Management
New `consent` object for privacy compliance:
- **Consent Tracking**: `consent_id`, `status`, `granted_at`, `expires_at`
- **Scope Definition**: Granular permissions (recording, analytics, storage, ai_processing)
- **Version Control**: Policy version tracking
- **Context**: User agent, hashed IP for audit trails

#### Data Provenance
New `provenance` object for data lineage:
- **Source Tracking**: `source_system`, `created_at`, `created_by`
- **Transformation History**: Complete processing pipeline tracking
- **Compliance**: Data retention policies and compliance flags
- **Quality**: Processing chain and validation history

#### Enhanced Custom Data
- **Integration Data**: Third-party service integration results
- **Experimental Features**: Beta feature data isolation
- **Provider Extensions**: Structured provider-specific extensions

#### Audit Enhancements
- **Processing Metrics**: `processed_at`, `processing_duration_ms`
- **Validation Tracking**: `validation_errors` array
- **Integrity**: Message `checksum` for tamper detection

### 🔧 **Technical Improvements**

#### Pydantic v2 Compatibility
- Updated to modern `@field_validator` and `@model_validator` syntax
- Uses `model_dump()` instead of deprecated `dict()` method
- Full type safety and validation

#### Enhanced Validation
- Cross-field validation (timestamps, capability timing)
- Consent status validation with business logic
- Version compatibility checking

#### Utility Methods
- `compute_checksum()`: Message integrity verification
- `to_v03_compatible()`: Backward compatibility conversion
- `upgrade_from_v03()`: Automatic v0.3 → v0.5 upgrade

## Migration Guide

### Automated Migration (Recommended)

```python
from vcp_v05_schema import VCPValidator

# Upgrade v0.3 message to v0.5
validator = VCPValidator()
v05_message = validator.upgrade_from_v03(v03_data)
```
### Manual Migration

#### 1. Update Version Declaration
```python
# Before (v0.3)
{
  "vcp_version": "0.3",
  ...
}

# After (v0.5)
{
  "vcp_version": "0.5",
  ...
}
```
#### 2. Add Required v0.5 Fields
```python
# Add to vcp_payload
"consent": {
  "consent_id": "consent_" + call_id,
  "status": "granted",
  "scope": ["recording", "analytics"],
  "version": "1.0"
},
"provenance": {
  "source_system": provider_name + "_webhook_api",
  "created_at": now_iso_string,
  "transformation_history": ["upgraded_from_v0.3"]
}
```
#### 3. Enhance Capabilities (Optional)
```python
# Before (v0.3) - simple strings
"capabilities_invoked": ["book_appointment"]

# After (v0.5) - rich objects (backward compatible)
"capabilities_invoked": [
  {
    "capability_id": "book_appointment",
    "capability_type": "tool_call",
    "invoked_at": "2025-10-14T14:30:00Z",
    "duration_ms": 2300,
    "success": true,
    "metadata": {"appointment_type": "consultation"}
  }
]
```
### Breaking Changes

#### ⚠️ **None for v0.3 Users**
VCP v0.5 maintains full backward compatibility with v0.3. All existing v0.3 messages will validate and process correctly.

#### ⚠️ **v0.4 Deprecation**
The incomplete v0.4 implementation is deprecated. Any systems using v0.4 should migrate to v0.5 immediately.

## Provider Integration Updates

### Webhook Mapping
Provider webhook mappings now generate v0.5-compliant VCP messages:

```python
# Updated VCPMapper generates v0.5 structure
vcp_mapper = VCPMapper(registry)
vcp_message = vcp_mapper.map_to_vcp("retell", webhook_payload)
# Returns v0.5 structure with full provenance, consent, and enhanced fields
```
### Example Provider Integration

```python
# Retell webhook → VCP v0.5
retell_webhook = {
  "event": "call_ended",
  "call": {
    "call_id": "retell_123",
    "transcript": "Hello, how can I help?",
    # ... other fields
  }
}

# Maps to comprehensive v0.5 structure
vcp_result = {
  "vcp_version": "0.5",
  "vcp_payload": {
    "call": {
      "call_id": "retell_123",
      "session_id": "sess_retell_retell_12", 
      "provider": "retell",
      # ... enhanced call data
    },
    "consent": { ... },
    "provenance": { 
      "source_system": "retell_webhook_api",
      "transformation_history": ["received_from_retell_webhook", "mapped_to_vcp_v0.5"]
    },
    # ... all other v0.5 fields
  }
}
```
## Validation & Testing

### Schema Validation
```python
from vcp_v05_schema import VCPValidator, VCPMessage

validator = VCPValidator()
message = VCPMessage(**your_data)
results = validator.validate_v05(message)

if results["errors"]:
    print(f"Validation errors: {results['errors']}")
if results["warnings"]:
    print(f"Validation warnings: {results['warnings']}")
```
### Compatibility Testing
```python
# Test v0.3 compatibility
v03_compatible = message.to_v03_compatible()
print(f"v0.3 compatible size: {len(json.dumps(v03_compatible))} bytes")

# Test checksum integrity
checksum = message.compute_checksum()
print(f"Message checksum: {checksum}")
```
## Governance for v1.0

### Version Lock Promise
When VCP reaches v1.0, we commit to:

1. **Schema Stability**: No breaking changes to v1.0 structure
2. **Backward Compatibility**: v1.0 systems must support v0.3, v0.5 messages
3. **Controlled Evolution**: Major changes require community RFC process
4. **LTS Support**: Long-term support for v1.0 with security updates

### v1.0 Roadmap
Planned v1.0 additions:
- **Real-time Streaming**: Live VCP updates during calls
- **Multi-modal Support**: Video, screen sharing context
- **Advanced Analytics**: ML-driven insights and predictions
- **Compliance Automation**: Automated GDPR, CCPA compliance
- **Integration Ecosystem**: Standard connectors for major platforms

### Community Process
Starting with v1.0, changes will follow:
1. **RFC Process**: Formal proposal and community review
2. **Reference Implementation**: Working code before specification
3. **Testing Suite**: Comprehensive validation and compatibility tests
4. **Migration Tools**: Automated upgrade utilities
5. **Documentation**: Complete guides and examples

## Implementation Timeline

- **✅ v0.5 Release**: October 2025 - Comprehensive schema
- **🔄 v0.6-v0.9**: Q1-Q3 2026 - Community feedback integration
- **🎯 v1.0 Target**: Q4 2026 - Production-locked specification

## Support & Resources

### Development Tools
- **Schema Library**: `vcp_v05_schema.py` with full validation
- **Provider Mappings**: Updated webhook transformations  
- **Operations Dashboard**: VoiceLens ops app with v0.5 support
- **Monitoring**: Change detection and health monitoring

### Documentation
- **Schema Reference**: Complete field documentation
- **Provider Guides**: Integration documentation per provider
- **Migration Tools**: Automated upgrade utilities
- **Best Practices**: Implementation guidelines

### Community
- **GitHub Issues**: Bug reports and feature requests
- **RFC Process**: Proposal and discussion forum  
- **Contact Information**: See [CONTACT-US.md]((./CONTACT-US.md)) for all support options
- **Community Sync**: See [LOGISTICS.md]((./LOGISTICS.md)) for planned meeting schedules (not yet active)

---

**Migration Deadline**: v0.3 support continues indefinitely. v0.4 systems should migrate to v0.5 by December 2025.

**Questions?** See [CONTACT-US.md]((./CONTACT-US.md)) for all available support channels.



================================================================================
📄 FILE: README_ENVIRONMENT.md
📝 TITLE: VoiceLens Environment Management
📊 SIZE: 3,408 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VoiceLens Environment Management

This directory contains scripts and configuration for managing the VoiceLens virtual environment consistently across deployments.

## Files Overview

- `requirements.txt` - Python dependencies (no version constraints for flexible resolution)
- `activate_env.sh` - Simple environment activation script
- `activate_and_deploy.sh` - Full deployment script with environment setup
- `ensure_venv.py` - Python script to verify environment status
- `venv/` - Virtual environment directory
- `deploy_local_prod.py` - 🎯 **Recommended** - Production deployment script
- `voicelens_ops_app.py` - Main Flask application (VoiceLens Operations Dashboard)

## Quick Start

### 1. Activate Environment (Manual)
```bash
source venv/bin/activate
```
### 2. Activate Environment (Script)
```bash
source activate_env.sh
```
### 3. Full Deployment (Automatic)
```bash
./activate_and_deploy.sh
```
### 4. VoiceLens Production Deployment (Recommended)
```bash
# Activate environment first
source activate_env.sh

# Run production deployment
python deploy_local_prod.py
```
### 4. Verify Environment (Python)
```bash
python ensure_venv.py
```
## Environment Scripts

### `activate_env.sh`
- Sources the virtual environment
- Creates venv if it doesn't exist
- Installs dependencies if needed
- Sets Flask environment variables

**Usage:**
```bash
source activate_env.sh  # Note: must be sourced, not executed
```
### `activate_and_deploy.sh`
- Full deployment script
- Creates/activates virtual environment
- Installs/updates dependencies
- Starts the VoiceLens application
- Uses port 8080 by default (avoids macOS AirPlay port 5000)

**Usage:**
```bash
./activate_and_deploy.sh
# Or with custom port:
PORT=9000 ./activate_and_deploy.sh
```
### `ensure_venv.py`
- Verifies virtual environment status
- Checks Python executable path
- Validates key dependencies
- Returns exit code 0 on success, 1 on failure

**Usage:**
```bash
python ensure_venv.py
```
## Port Configuration

By default, the deployment script uses port 8080 to avoid conflicts with macOS AirPlay Receiver (which uses port 5000). You can override this:

```bash
PORT=9000 ./activate_and_deploy.sh
```
## Dependency Management

The `requirements.txt` file uses flexible version resolution:
- No upper bounds to avoid dependency conflicts
- No lower bounds to allow latest compatible versions
- Let pip resolve the best versions automatically

To update dependencies:
```bash
source venv/bin/activate
pip install --upgrade -r requirements.txt
```
## Troubleshooting

### Virtual Environment Not Found
```bash
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```
### Port Conflicts
If port 8080 is already in use, specify a different port:
```bash
# Use different port
PORT=9000 ./activate_and_deploy.sh

# Or check what's using a specific port
lsof -i :8080
```
### Dependencies Missing
```bash
source venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
```
## Environment Variables

The scripts set these environment variables:
- `FLASK_APP=deploy_local_prod.py` (or voicelens_ops_app.py)
- `FLASK_ENV=production` 
- `PORT=8080` (or custom value)
- `VIRTUAL_ENV=/path/to/venv`

## Integration with CI/CD

For automated deployments, use the verification script:

```bash
# In your deployment pipeline
python ensure_venv.py || exit 1
./activate_and_deploy.sh
```



================================================================================
📄 FILE: CONTACT-US.md
📝 TITLE: Contact Us
📊 SIZE: 3,033 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Contact Us

This document serves as the centralized contact directory for the Voice Context Protocol (VCP) and VoiceLens ecosystem.

## Primary Contact

**General Inquiries & Support**
- **Email**: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
- **Purpose**: All general inquiries, technical support, partnership discussions, and administrative matters

## Contact Categories

### 🔐 Security & Vulnerability Reporting
For security vulnerabilities, data privacy concerns, and other security-related matters:
- **Email**: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
- **Response Time**: 24-48 hours
- **Process**: Please include "SECURITY" in the subject line for priority handling

### 💼 Business & Partnerships  
For business inquiries, partnership opportunities, and commercial discussions:
- **Email**: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
- **Process**: Please include "BUSINESS" in the subject line

### 🛠️ Technical Support
For technical issues, integration support, and developer questions:
- **Email**: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
- **GitHub Issues**: [voicelens-scripts/issues](https://github.com/prompted365/voicelens-scripts/issues)
- **Process**: For bug reports and feature requests, please use GitHub Issues when possible

### 📋 Governance & Community
For governance questions, community matters, and protocol development:
- **Email**: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
- **Process**: Please include "GOVERNANCE" in the subject line

## Community Channels

### GitHub
- **Repository**: [prompted365/voicelens-scripts](https://github.com/prompted365/voicelens-scripts)
- **Issues**: Bug reports, feature requests, technical discussions
- **Discussions**: Community discussions, proposals, and Q&A

### Documentation
- **Main Documentation**: Available in this repository
- **API Documentation**: See `/docs` directory
- **Integration Guides**: See provider-specific documentation

## Response Times

- **General Inquiries**: 2-3 business days
- **Technical Support**: 1-2 business days
- **Security Issues**: 24-48 hours
- **Business Inquiries**: 2-3 business days

## Future Contact Methods

*The following contact methods are planned but not yet active:*

- Discord Community Server
- Dedicated support portal
- Community mailing lists
- Regional support contacts
- Video conference office hours

For updates on new contact methods, please check this document regularly or watch the repository for updates.

## Contact Information Updates

This document is maintained as the single source of truth for VCP contact information. If you find outdated contact references elsewhere in the documentation, please:

1. File an issue on GitHub
2. Email us at [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
3. Submit a pull request with the correction

---

**Last Updated**: January 2024
**Document Version**: 1.0.0

For immediate assistance, please email: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)



================================================================================
📄 FILE: HANDOVER_GUIDE.md
📝 TITLE: VoiceLens Dataset Generation & Delivery Handover Guide
📊 SIZE: 8,369 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VoiceLens Dataset Generation & Delivery Handover Guide

## Overview

This guide provides complete instructions for generating and delivering synthetic HVAC conversation datasets using the VoiceLens system. All processes have been tested and validated with a successful 1,800 conversation delivery achieving 100% success rate.

## Quick Start Commands

### Generate and Send 60-Day Dataset (1,800 conversations)
```bash
# 1. Generate dataset
python -m voicelens_seeder.cli generate conversations --count 1800 --start-days-ago 60 --out ./synthetic_60d_data --seed 42

# 2. Send to webhook
python send_large_batch.py ./synthetic_60d_data https://ogqwehdmnlvpdjxdqhkt.functions.supabase.co/vcp-webhook/a/voiceai4hvac/c/localhvac/s/YXjNgJgboxK2VTJt1uDQHJ
```
### Generate Other Time Periods
```bash
# 30 days (900 conversations)
python -m voicelens_seeder.cli generate conversations --count 900 --start-days-ago 30 --out ./synthetic_30d_data --seed 42

# 90 days (2,700 conversations) 
python -m voicelens_seeder.cli generate conversations --count 2700 --start-days-ago 90 --out ./synthetic_90d_data --seed 42

# Custom date range with specific provider
python -m voicelens_seeder.cli generate conversations --count 500 --start-days-ago 45 --provider retell --seed 100
```
## System Architecture

### Prerequisites
- Python 3.13+ with virtual environment
- VoiceLens CLI installed (`voicelens_seeder` module)
- Required packages: `aiohttp`, `aiofiles`, `tqdm`

### Project Structure
```
voicelens-scripts/
├── src/voicelens_seeder/           # CLI source code
├── synthetic_60d_data/             # Generated datasets
├── reports/                        # Analysis and quality reports
├── send_large_batch.py            # Async batch delivery tool
├── analyze_delivery.py            # Quality analysis tool
├── manifest.json                  # Complete dataset manifest
└── delivery.log                   # Delivery execution logs
```
## Webhook Configuration

### Endpoint Details
- **URL**: `https://ogqwehdmnlvpdjxdqhkt.functions.supabase.co/vcp-webhook/a/voiceai4hvac/c/localhvac/s/YXjNgJgboxK2VTJt1uDQHJ`
- **Method**: POST
- **Content-Type**: application/json
- **Expected Response**: HTTP 200 for success
- **Rate Limits**: Tested stable at 10 RPS, supports up to 15 RPS
- **Timeout**: 30 seconds per request

### Payload Format
Each conversation is sent as a VCP 0.3 compliant JSON object with structure:
```json
{
  "call_id": "uuid",
  "vcp_version": "0.3",
  "vcp_payload": {
    "call": { "provider": "retell|vapi|bland", "duration_sec": 130, ... },
    "outcomes": { "objective": {...}, "perceived": [...] },
    "custom": { "outcome_hint": "scenario_name", "synthetic": true }
  }
}
```
## Volume Guidelines

### Recommended Conversation Counts
| Time Period | Conversations | Avg/Day | Use Case |
|-------------|---------------|---------|----------|
| 30 days     | 900          | 30      | Quick testing |
| 60 days     | 1,800        | 30      | Standard dataset |
| 90 days     | 2,700        | 30      | Extended analysis |
| 120 days    | 3,600        | 30      | Long-term trends |

### Performance Expectations
- **Generation**: 40 conversations/second
- **Delivery**: 9-10 conversations/second  
- **60-day dataset**: ~5 minutes total (1 min generate + 3 min deliver)
- **Memory usage**: ~50MB for 1,800 conversations

## Scenario Distribution

The system generates 7 different HVAC scenarios with realistic distributions:

| Scenario | Weight | Description |
|----------|--------|-------------|
| scheduled_callback | ~20% | Follow-up appointments |
| spam_filtered | ~18% | Filtered unwanted calls |
| booked_service | ~17% | Successful service bookings |
| emergency_service | ~16% | Urgent HVAC issues |
| live_transfer | ~14% | Escalation to human agents |
| out_of_service_area | ~9% | Geographic limitations |
| quote_requested | ~5% | Price quotation requests |

## Quality Assurance Process

### Automatic Validation
After delivery, run quality analysis:
```bash
python analyze_delivery.py ./synthetic_60d_data
```
### Quality Metrics Tracked
- ✅ **Count Accuracy**: 100% delivery success rate
- ✅ **Scenario Diversity**: 7 distinct scenarios
- ✅ **Provider Balance**: Equal distribution across Retell/Vapi/Bland
- ✅ **HVAC Terminology**: 100% relevant content
- ✅ **PII Compliance**: Zero personal information
- ✅ **Temporal Distribution**: Realistic time patterns

### Expected Quality Score: 100/100 (Grade A)

## Delivery Configuration

### Standard Settings (Tested & Recommended)
```python
DeliveryConfig(
    webhook_url=WEBHOOK_URL,
    max_concurrent=8,        # Conservative concurrency
    rate_limit_rps=10.0,     # Requests per second
    retry_attempts=3,        # Auto-retry failed requests
    retry_backoff=2.0,       # Exponential backoff
    timeout=30.0             # Request timeout
)
```
### High-Volume Settings (For 5,000+ conversations)
```python
DeliveryConfig(
    max_concurrent=12,
    rate_limit_rps=15.0,
    retry_attempts=5,
    timeout=45.0
)
```
## Error Handling & Recovery

### Resume Interrupted Deliveries
The system automatically creates `delivery_progress.json` to track completed deliveries:
```bash
# If delivery is interrupted, simply re-run the same command
python send_large_batch.py ./synthetic_60d_data [WEBHOOK_URL]
# It will resume from where it left off
```
### Common Issues & Solutions

#### Generation Issues
```bash
# Module not found
source venv/bin/activate
pip install -e .

# Permission denied on output directory
mkdir -p ./output_directory
chmod 755 ./output_directory
```
#### Delivery Issues
```bash
# High error rate
# Reduce concurrency and rate limits in send_large_batch.py (lines 276-283)

# Webhook timeouts
# Increase timeout setting or check webhook health
curl -X POST [WEBHOOK_URL] -H "Content-Type: application/json" -d '{"test": true}'
```
## Customization Options

### Custom Seed for Different Data
```bash
# Each seed produces different synthetic conversations
python -m voicelens_seeder.cli generate conversations --seed 100  # Different dataset
python -m voicelens_seeder.cli generate conversations --seed 200  # Another variation
```
### Provider-Specific Generation
```bash
# Only Retell conversations
python -m voicelens_seeder.cli generate conversations --provider retell --count 600

# All providers (default)
python -m voicelens_seeder.cli generate conversations --provider all --count 1800
```
### VCP Mode Selection
```bash
# GTM mode (default) - Optimized for Go-To-Market scenarios
python -m voicelens_seeder.cli generate conversations --vcp-mode gtm

# Full mode - Complete VCP payload structure
python -m voicelens_seeder.cli generate conversations --vcp-mode full
```
## Monitoring & Logs

### Delivery Monitoring
- Real-time progress bar during delivery
- Automatic retry with exponential backoff
- Complete success/failure logging in `delivery.log`

### Log Files Generated
- `delivery.log` - Complete delivery execution log
- `reports/delivery_analysis.json` - Detailed quality analysis
- `reports/summary.json` - Executive summary statistics
- `reports/quality.md` - Human-readable quality report

## Future Enhancements

### Planned Improvements
1. **Conversation Transcripts**: Turn-by-turn dialogue generation
2. **Spanish Language Support**: Bilingual conversation scenarios  
3. **Customer Journey Tracking**: Link related conversations over time
4. **Geographic Distribution**: Regional HVAC service patterns
5. **Sentiment Analysis**: Customer satisfaction scoring

### Scalability Considerations
- Current system handles 10,000+ conversations/hour
- Webhook tested stable at 10 RPS, scalable to 15+ RPS
- For enterprise volumes (50,000+), consider parallel webhook endpoints

## Contact & Support

### Files for Reference
- `manifest.json` - Complete dataset documentation
- `reports/quality.md` - Quality assessment details
- `src/voicelens_seeder/cli.py` - CLI implementation
- `send_large_batch.py` - Delivery system source

### Reproducibility Commands
All operations are fully reproducible with the provided seeds and commands. Store the exact CLI versions and dependency versions for guaranteed reproducibility.

---

**Last Updated**: October 2025  
**Tested With**: 1,800 conversations, 100% success rate  
**Next Review**: After 10,000+ conversation deliveries



================================================================================
📄 FILE: VCP_IMPLEMENTATION_CONSISTENCY_FRAMEWORK.md
📝 TITLE: VCP Implementation Consistency Framework
📊 SIZE: 16,955 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VCP Implementation Consistency Framework
**Version 1.0 | October 2025**

## Overview

This framework ensures consistent behavior, compatibility, and coordinated evolution across all VCP implementations (Python, Rust, TypeScript) while enabling language-specific optimizations. It defines the technical processes, testing requirements, and quality gates that maintain VCP's integrity as a cross-platform standard.

## 1. Multi-Implementation Architecture

### 1.1 Implementation Ecosystem
```mermaid
graph TD
    A[VCP v0.5 Canonical Schema] --> B[Python Implementation]
    A --> C[Rust Implementation] 
    A --> D[TypeScript Implementation]
    
    B --> E[voicelens-scripts]
    B --> F[PyPI Packages]
    
    C --> G[voicelens-vcp-rust]
    C --> H[Crates.io Packages]
    
    D --> I[Voice Lens Platform]
    D --> J[NPM Packages]
    
    K[Compatibility Test Suite] --> B
    K --> C
    K --> D
    
    L[Provider Mappings] --> B
    L --> C
    L --> D
```
### 1.2 Implementation Responsibilities

#### Python Implementation (voicelens-scripts)
- **Role**: Production reference implementation
- **Strengths**: Provider integrations, operational maturity
- **Responsibilities**:
  - VCP schema evolution prototyping
  - Provider mapping validation
  - Production deployment patterns
  - Migration tooling

#### Rust Implementation (voicelens-vcp-rust)  
- **Role**: High-performance, type-safe implementation
- **Strengths**: Memory safety, performance, concurrency
- **Responsibilities**:
  - Performance benchmarking baseline
  - Type system validation
  - WebAssembly compilation targets
  - Security-critical deployments

#### TypeScript Implementation (Voice Lens Platform)
- **Role**: Web-first, developer-friendly implementation
- **Strengths**: Browser compatibility, npm ecosystem
- **Responsibilities**:
  - Web platform integrations
  - Developer experience optimization
  - Frontend/backend compatibility
  - JavaScript ecosystem bridge

## 2. Schema Synchronization Process

### 2.1 Schema Change Propagation
```bash
# Schema Evolution Workflow
1. VCP Schema Change (VIP approved)
   ├── Python: Update pydantic models
   ├── Rust: Update serde structs  
   └── TypeScript: Update TypeScript interfaces

2. Compatibility Validation
   ├── Cross-implementation test execution
   ├── Provider mapping verification
   └── Migration path testing

3. Coordinated Release
   ├── Implementation-specific releases
   ├── Documentation updates
   └── Community notification
```
### 2.2 Schema Consistency Requirements

#### Core Schema Elements:
```json
{
  "vcp_version": "0.5",
  "vcp_payload": {
    "call": { /* identical structure across implementations */ },
    "model_selection": { /* identical structure */ },
    "outcomes": { /* identical structure */ },
    "hcr": { /* identical structure */ },
    "artifacts": { /* identical structure */ }
  },
  "audit": { /* identical structure */ }
}
```
#### Implementation-Specific Optimizations:
- **Python**: Pydantic field validators and custom serializers
- **Rust**: Custom serde deserializers and compile-time validation
- **TypeScript**: Branded types and runtime type guards

## 3. Compatibility Test Suite

### 3.1 Test Suite Architecture
```
vcp-compatibility-tests/
├── schema/
│   ├── validation/           # Schema validation tests
│   ├── serialization/        # JSON serialization tests
│   └── migration/           # Version migration tests
├── fixtures/
│   ├── golden/              # Golden test files
│   ├── provider-samples/    # Real provider webhook samples
│   └── edge-cases/         # Edge case test data
├── provider-mappings/
│   ├── retell/             # Retell AI specific tests
│   ├── vapi/               # Vapi specific tests
│   ├── bland/              # Bland AI specific tests
│   ├── elevenlabs/         # ElevenLabs specific tests
│   └── openai/             # OpenAI Realtime specific tests
├── performance/
│   ├── benchmarks/         # Performance benchmark tests
│   └── memory/             # Memory usage tests
└── integration/
    ├── cross-impl/         # Cross-implementation tests
    └── e2e/               # End-to-end workflow tests
```
### 3.2 Test Categories

#### Schema Validation Tests
```python
# Example test structure
def test_vcp_message_validation():
    """Ensure all implementations validate VCP messages identically"""
    test_message = load_fixture("valid_vcp_message.json")
    
    # All implementations must produce identical validation results
    python_result = python_validator.validate(test_message)
    rust_result = rust_validator.validate(test_message)  
    typescript_result = typescript_validator.validate(test_message)
    
    assert python_result.is_valid == rust_result.is_valid == typescript_result.is_valid
    assert python_result.errors == rust_result.errors == typescript_result.errors
```
#### Provider Mapping Tests
```python
def test_provider_webhook_mapping():
    """Ensure all implementations map provider webhooks identically"""
    webhook_payload = load_fixture("retell_webhook.json")
    
    python_vcp = python_mapper.map_to_vcp("retell", webhook_payload)
    rust_vcp = rust_mapper.map_to_vcp("retell", webhook_payload)
    typescript_vcp = typescript_mapper.map_to_vcp("retell", webhook_payload)
    
    # VCP output must be functionally identical (ignoring serialization differences)
    assert normalize_vcp(python_vcp) == normalize_vcp(rust_vcp) == normalize_vcp(typescript_vcp)
```
#### Migration Tests  
```python
def test_version_migration():
    """Ensure all implementations migrate versions identically"""
    v03_message = load_fixture("vcp_v03_message.json")
    
    python_v05 = python_migrator.upgrade_to_v05(v03_message)
    rust_v05 = rust_migrator.upgrade_to_v05(v03_message)
    typescript_v05 = typescript_migrator.upgrade_to_v05(v03_message)
    
    assert normalize_vcp(python_v05) == normalize_vcp(rust_v05) == normalize_vcp(typescript_v05)
```
### 3.3 Performance Benchmarks
```yaml
# Performance requirements across implementations
benchmarks:
  schema_validation:
    minimum_throughput: 10000 # messages/second
    max_latency_p99: 10       # milliseconds
    
  provider_mapping:
    minimum_throughput: 5000  # webhooks/second
    max_latency_p99: 20       # milliseconds
    
  serialization:
    minimum_throughput: 50000 # messages/second
    max_latency_p99: 2        # milliseconds

performance_baselines:
  python: "baseline implementation"
  rust: "2-10x faster than Python"
  typescript: "within 50% of Python performance"
```
## 4. Continuous Integration Matrix

### 4.1 CI Pipeline Architecture
```yaml
# .github/workflows/vcp-compatibility.yml
name: VCP Cross-Implementation Compatibility

on: [push, pull_request]

jobs:
  compatibility-tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        implementation: [python, rust, typescript]
        test-suite: [schema, provider-mappings, migration, performance]
    
    steps:
      - name: Setup Implementation Environment
      - name: Run Test Suite
      - name: Upload Results
      - name: Cross-Implementation Comparison
```
### 4.2 Quality Gates

#### Pre-Merge Requirements:
- ✅ All schema validation tests pass (100%)
- ✅ All provider mapping tests pass (100%)  
- ✅ Migration tests pass (100%)
- ✅ Performance benchmarks within acceptable range
- ✅ Cross-implementation compatibility verified
- ✅ Documentation updated

#### Release Requirements:
- ✅ Full compatibility test suite passes
- ✅ Integration tests with real provider data
- ✅ Performance regression analysis
- ✅ Security vulnerability scans
- ✅ Documentation completeness check

## 5. Provider Integration Consistency

### 5.1 Provider Mapping Registry
```typescript
// Centralized provider mapping definitions
interface ProviderMapping {
  provider: string;
  version: string;
  mappings: {
    [vcpField: string]: {
      path: string;              // JSONPath to provider field
      transform?: string;        // Transformation function name
      required: boolean;         // Whether field is required
      validation?: string;       // Validation rules
    };
  };
  custom_fields: {
    [customField: string]: any; // Provider-specific extensions
  };
}

// Example: Retell AI mapping
const retellMapping: ProviderMapping = {
  provider: "retell",
  version: "1.0",
  mappings: {
    "call.call_id": { path: "call.call_id", required: true },
    "call.duration_sec": { path: "call.duration", required: true },
    "call.direction": { 
      path: "call.direction", 
      transform: "normalizeDirection",
      required: false 
    }
  },
  custom_fields: {
    "custom.provider_specific.retell.channel": "call.channel"
  }
};
```
### 5.2 Transformation Functions
```python
# Shared transformation logic (implemented in each language)
class VCPTransformations:
    @staticmethod
    def normalize_direction(value: str) -> CallDirection:
        """Normalize provider direction to VCP CallDirection enum"""
        direction_map = {
            "inbound": CallDirection.INBOUND,
            "outbound": CallDirection.OUTBOUND,
            "incoming": CallDirection.INBOUND,
            "outgoing": CallDirection.OUTBOUND,
        }
        return direction_map.get(value.lower(), CallDirection.INBOUND)
    
    @staticmethod
    def normalize_phone_number(value: str) -> str:
        """Normalize phone numbers to E.164 format"""
        # Implementation must be identical across all languages
        pass
        
    @staticmethod  
    def compute_perception_gap(perceived: List[float], objective: float) -> PerceptionGap:
        """Compute perception gap with identical algorithm"""
        # Implementation must be identical across all languages
        pass
```
## 6. Version Migration Framework

### 6.1 Migration Strategy
```mermaid
graph LR
    A[VCP v0.3] --> B[Migration Layer]
    B --> C[VCP v0.5]
    
    D[Provider Webhook] --> E[Provider Mapping]
    E --> F[VCP v0.5]
    
    G[Legacy VCP] --> H[Version Detector]
    H --> I[Appropriate Migrator]
    I --> F
```
### 6.2 Migration Requirements
- **Lossless**: No data lost during version upgrades
- **Deterministic**: Identical results across implementations
- **Reversible**: Ability to downgrade when possible
- **Validated**: Migration results validated against schema

### 6.3 Migration Test Matrix
```yaml
migration_tests:
  v03_to_v05:
    - basic_call_data
    - provider_webhooks  
    - edge_cases
    - malformed_input
    
  v04_to_v05:
    - incomplete_v04_data
    - v04_extensions
    - backward_compatibility
    
  downgrade_tests:
    - v05_to_v03_compatible
    - feature_loss_warnings
    - data_preservation
```
## 7. Development Workflow

### 7.1 Schema Change Process
1. **VIP Proposal**: Technical specification for schema change
2. **Multi-Implementation Impact Assessment**: Each team evaluates impact
3. **Prototype Implementation**: Implement in primary language (Python)
4. **Cross-Implementation Development**: Parallel development in Rust/TypeScript
5. **Compatibility Testing**: Full test suite execution
6. **Community Review**: Public review period
7. **Coordinated Release**: Synchronized releases

### 7.2 Implementation-Specific Changes
1. **Local Development**: Language-specific optimizations and fixes
2. **Compatibility Validation**: Ensure behavior remains consistent
3. **Performance Testing**: Validate performance improvements
4. **Documentation Update**: Update implementation-specific docs
5. **Independent Release**: Can release without coordinating other implementations

## 8. Monitoring and Observability

### 8.1 Compatibility Monitoring
```python
# Automated compatibility monitoring
class CompatibilityMonitor:
    def monitor_implementations(self):
        """Continuous monitoring of implementation behavior"""
        test_cases = self.load_test_cases()
        
        for test_case in test_cases:
            python_result = self.run_python_test(test_case)
            rust_result = self.run_rust_test(test_case)  
            typescript_result = self.run_typescript_test(test_case)
            
            if not self.results_equivalent(python_result, rust_result, typescript_result):
                self.alert_compatibility_issue(test_case, [python_result, rust_result, typescript_result])
```
### 8.2 Performance Monitoring
- **Benchmark Regression Detection**: Alert on >5% performance degradation
- **Memory Usage Tracking**: Monitor memory consumption patterns
- **Throughput Monitoring**: Track processing throughput over time
- **Latency Percentiles**: Monitor p50, p95, p99 latencies

## 9. Error Handling and Debugging

### 9.1 Consistent Error Reporting
```typescript
// Standardized error format across implementations
interface VCPError {
  code: string;           // Standardized error code
  message: string;        // Human-readable message
  field_path?: string;    // JSONPath to problematic field
  provider?: string;      // Provider name if relevant
  implementation: string; // Which implementation generated error
  context: any;          // Additional context
}

// Example error codes (consistent across implementations)
const VCP_ERROR_CODES = {
  SCHEMA_VALIDATION_FAILED: "VCP_E001",
  PROVIDER_MAPPING_FAILED: "VCP_E002", 
  VERSION_MIGRATION_FAILED: "VCP_E003",
  FIELD_TYPE_MISMATCH: "VCP_E004",
  REQUIRED_FIELD_MISSING: "VCP_E005",
};
```
### 9.2 Debug Information
- **Trace IDs**: Unique identifiers for tracking across implementations
- **Debug Logs**: Standardized debug information format
- **Error Context**: Rich context information for troubleshooting
- **Implementation Markers**: Clear identification of which implementation processed data

## 10. Security Consistency

### 10.1 Security Requirements
- **Input Validation**: Identical validation across implementations
- **Provider Signature Verification**: Consistent cryptographic verification
- **Data Sanitization**: Consistent PII/sensitive data handling
- **Error Information Disclosure**: Consistent error information handling

### 10.2 Security Testing
```python
# Security test requirements for all implementations
def test_input_validation_consistency():
    """Ensure all implementations handle malicious input identically"""
    malicious_inputs = load_security_test_vectors()
    
    for malicious_input in malicious_inputs:
        python_response = python_implementation.process(malicious_input)
        rust_response = rust_implementation.process(malicious_input)
        typescript_response = typescript_implementation.process(malicious_input)
        
        # All implementations must reject malicious input in same way
        assert all(response.is_error for response in [python_response, rust_response, typescript_response])
```
## 11. Documentation Consistency

### 11.1 Documentation Requirements
- **API Documentation**: Identical API documentation across implementations
- **Example Code**: Equivalent examples in each language
- **Migration Guides**: Consistent migration instructions
- **Integration Guides**: Provider integration guides for each implementation

### 11.2 Documentation Validation
```bash
# Automated documentation consistency checking
./validate-docs.sh --check-examples --validate-apis --cross-reference
```
## 12. Implementation Timeline

### Phase 1: Foundation (Q4 2025)
- ✅ Establish governance charter
- ✅ Create compatibility test framework
- ✅ Set up CI/CD pipelines
- ✅ Define quality gates

### Phase 2: Harmonization (Q1 2026)  
- 🔄 Implement full compatibility test suite
- 🔄 Establish performance benchmarks
- 🔄 Create provider mapping registry
- 🔄 Set up monitoring systems

### Phase 3: Optimization (Q2 2026)
- 📋 Performance optimization projects  
- 📋 Advanced security features
- 📋 Developer experience improvements
- 📋 Community tooling

### Phase 4: Foundation Transition (Q3-Q4 2026)
- 📋 Evaluate foundation transition
- 📋 Establish neutral governance
- 📋 Community growth initiatives
- 📋 Industry standard recognition

---

## Conclusion

This Implementation Consistency Framework ensures VCP maintains its integrity as a cross-platform standard while enabling each implementation to leverage language-specific advantages. The framework provides the technical rigor necessary for VCP to become the definitive voice AI interoperability protocol.

**Key Success Metrics**:
- 100% compatibility across implementations for core functionality
- <5% performance variance (accounting for language characteristics)
- Coordinated releases within 30 days across implementations
- Zero compatibility regressions post-release

---

*This framework is a living document, evolved through practical experience and community feedback.*



================================================================================
📄 FILE: VCP_GOVERNANCE_CHARTER.md
📝 TITLE: Voice Context Protocol (VCP) Governance Charter
📊 SIZE: 15,151 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Voice Context Protocol (VCP) Governance Charter
**Version 1.0 | October 2025**

## Executive Summary

The Voice Context Protocol (VCP) is a critical open-source standard for voice AI interoperability, implemented across multiple programming languages and platforms:

- **Python Implementation**: voicelens-scripts (production, comprehensive)
- **Rust Implementation**: voicelens-vcp-rust (high-performance, type-safe)
- **TypeScript Implementation**: Voice Lens Platform (web-focused)
- **Canonical v0.5 Schema**: Definitive specification across all implementations

This charter establishes centralized governance to ensure consistency, compatibility, and coordinated evolution across all VCP implementations while enabling language-specific optimizations.

## 1. Governance Principles

### 1.1 Core Tenets
- **Schema Unity**: Single source of truth for VCP specification
- **Implementation Freedom**: Language-specific optimizations encouraged within spec bounds  
- **Backward Compatibility**: Strict semver adherence across all implementations
- **Cross-Platform Testing**: Comprehensive compatibility validation
- **Community-Driven**: Open governance with transparent decision-making

### 1.2 Decision-Making Philosophy
- **Consensus First**: Technical decisions through working group consensus
- **Evidence-Based**: Decisions backed by data, testing, and real-world usage
- **Implementation Agnostic**: Specification decisions independent of any single implementation
- **Security by Default**: Security implications considered in all changes

## 2. Organizational Structure

### 2.1 VCP Technical Steering Committee (TSC)
**Purpose**: Strategic direction, conflict resolution, and final decisions on breaking changes

**Composition** (7 members):
- **VCP Specification Lead** (1): Owns canonical schema and versioning
- **Implementation Leads** (3): Python, Rust, TypeScript lead maintainers  
- **Community Representatives** (2): Provider integrators and end-user advocates
- **Security Officer** (1): Security implications and vulnerability management

**Decision Rights**:
- VCP major version releases (breaking changes)
- Governance charter changes
- Working group creation/dissolution
- Conflict escalation resolution
- Foundation transition decisions

**Meeting Cadence**: Monthly, with emergency sessions as needed
**Quorum**: 5 of 7 members
**Decision Process**: Consensus preferred, majority vote (5/7) if needed

### 2.2 VCP Schema Working Group (SWG)
**Purpose**: Technical oversight of VCP specification evolution

**Composition**:
- Schema Working Group Chair (elected annually)
- Implementation Leads (Python, Rust, TypeScript)
- Provider Integration Specialists (2-3)
- Community Contributors (as needed)

**Responsibilities**:
- VCP schema evolution and versioning
- VIP (VCP Improvement Proposal) review and approval
- Cross-implementation compatibility requirements
- Migration path planning and testing
- Extension registry management

### 2.3 Implementation Working Groups
**Purpose**: Language/platform-specific implementation coordination

#### 2.3.1 Python Implementation WG
- **Lead**: Python VoiceLens Scripts maintainer
- **Scope**: voicelens-scripts, PyPI packages, Python-specific optimizations
- **Meeting**: Bi-weekly

#### 2.3.2 Rust Implementation WG  
- **Lead**: Rust VCP maintainer
- **Scope**: voicelens-vcp-rust, crates.io packages, performance optimizations
- **Meeting**: Bi-weekly

#### 2.3.3 TypeScript Implementation WG
- **Lead**: Voice Lens Platform maintainer  
- **Scope**: NPM packages, web platform integrations, browser compatibility
- **Meeting**: Bi-weekly

### 2.4 Provider Integration Council (PIC)
**Purpose**: Voice AI provider representation and integration guidance

**Composition**:
- Representatives from major providers (Retell, Vapi, Bland, ElevenLabs, OpenAI)
- Independent integrator representatives
- Community provider advocates

**Responsibilities**:
- Provider-specific mapping requirements
- New provider integration guidance
- Breaking change impact assessment
- Compliance and certification input

## 3. Technical Governance

### 3.1 VCP Improvement Proposal (VIP) Process
**Modeled after Rust RFCs and Python PEPs**

#### VIP Lifecycle:
1. **Ideation**: Community discussion in GitHub Discussions
2. **Draft VIP**: Technical specification document
3. **Working Group Review**: Schema WG technical review
4. **Implementation Feedback**: All implementations assess feasibility
5. **Community Comment**: 14-day public comment period
6. **Final Review**: Schema WG final assessment
7. **TSC Approval**: For breaking changes or major features
8. **Implementation**: Coordinated rollout across implementations

#### VIP Categories:
- **Core**: Changes to fundamental VCP schema (requires TSC approval)
- **Extension**: New optional fields or capabilities (SWG approval)
- **Implementation**: Language-specific optimization (Implementation WG)
- **Process**: Governance or tooling changes (TSC approval)

### 3.2 Version Management
**Unified Versioning Across All Implementations**

#### Schema Versioning (SemVer):
- **MAJOR**: Breaking changes requiring migration (0.5 → 1.0)
- **MINOR**: Backward-compatible additions (0.5.0 → 0.5.1)
- **PATCH**: Bug fixes and clarifications (0.5.1 → 0.5.2)

#### Implementation Versioning:
- **Schema Parity**: All implementations must support current VCP version
- **Release Coordination**: Synchronized releases within 30 days
- **Feature Flags**: New features behind flags until cross-implementation ready

#### Deprecation Policy:
- **Notice Period**: Minimum 6 months for MINOR deprecations
- **Migration Path**: Clear upgrade documentation and tooling
- **Support Window**: Previous MAJOR version supported 18 months

### 3.3 Cross-Implementation Compatibility

#### Canonical Test Suite:
```
vcp-compatibility-tests/
├── schema/                 # JSON Schema validation tests
├── fixtures/               # Golden test data files
├── provider-mappings/      # Provider-specific test cases  
├── migration/             # Version upgrade tests
└── performance/           # Benchmark tests
```
#### Compatibility Requirements:
- **Message Interoperability**: All implementations must produce compatible JSON
- **Provider Mapping**: Identical output for provider webhook transformations
- **Schema Validation**: Consistent validation behavior across implementations
- **Migration**: Identical upgrade/downgrade behavior

#### Testing Matrix:
| Implementation | Schema Tests | Provider Tests | Migration Tests | Performance |
|----------------|-------------|----------------|-----------------|-------------|
| Python         | ✅ Required | ✅ Required    | ✅ Required     | ✅ Required |
| Rust           | ✅ Required | ✅ Required    | ✅ Required     | ✅ Required |
| TypeScript     | ✅ Required | ✅ Required    | ✅ Required     | ✅ Required |

## 4. Release Management

### 4.1 Release Trains
**Coordinated releases across all implementations**

#### Quarterly Release Schedule:
- **Q1 (January)**: Major feature release
- **Q2 (April)**: Provider integration updates
- **Q3 (July)**: Performance and optimization focus
- **Q4 (October)**: Stability and security focus

#### Emergency Releases:
- **Security**: Within 24-72 hours of vulnerability disclosure
- **Critical Bugs**: Within 1 week of confirmation
- **Provider Breakage**: Within 48 hours of provider API changes

### 4.2 Release Process
1. **VIP Implementation**: Features implemented across implementations
2. **Compatibility Testing**: Full test suite execution
3. **Beta Release**: 2-week beta period with community testing
4. **Documentation Update**: Synchronized documentation updates
5. **Coordinated Release**: All implementations released within 48 hours
6. **Post-Release**: Monitoring and hotfix readiness

### 4.3 Implementation-Specific Releases
- **Optimization Releases**: Language-specific performance improvements
- **Bug Fixes**: Implementation-specific fixes (coordinated notifications)
- **Dependency Updates**: Security and maintenance updates

## 5. Quality Assurance

### 5.1 Testing Requirements

#### Schema Compliance:
```python
# Required test coverage for all implementations:
- Schema validation (100% of VCP spec)
- Provider mapping accuracy (all supported providers)  
- Migration correctness (all version pairs)
- Performance benchmarks (documented baselines)
- Security validation (injection, overflow tests)
```
#### Cross-Implementation Tests:
```bash
# Shared test suite execution:
./run-compatibility-tests.sh --implementations python,rust,typescript
./run-provider-mapping-tests.sh --providers retell,vapi,bland
./run-migration-tests.sh --from-version 0.4 --to-version 0.5
```
### 5.2 Continuous Integration
- **GitHub Actions**: Automated testing on all PRs
- **Cross-Implementation CI**: Tests run against all implementations
- **Performance Regression**: Automated performance monitoring
- **Security Scanning**: Vulnerability detection in dependencies

### 5.3 Quality Gates
- **Schema Tests**: 100% pass rate required
- **Provider Tests**: All supported providers must pass
- **Documentation**: Complete API docs and examples
- **Performance**: No more than 5% regression without justification

## 6. Security Governance

### 6.1 Security Response Team
**Composition**:
- Security Officer (TSC member)
- Implementation security contacts (1 per implementation)
- External security advisor (if needed)

### 6.2 Vulnerability Management
1. **Private Disclosure**: See [CONTACT-US.md]((./CONTACT-US.md)) for current security contact information
2. **Assessment**: 48-hour initial assessment
3. **Coordination**: Cross-implementation impact analysis
4. **Patch Development**: Coordinated fix development
5. **Disclosure**: Public disclosure after patches available
6. **CVE Assignment**: CVE numbers for serious vulnerabilities

### 6.3 Security Requirements
- **Input Validation**: Strict validation of all VCP payloads
- **Memory Safety**: Rust implementation advantages leveraged
- **Cryptographic Standards**: Provider signature validation standards
- **Audit Trail**: All schema changes logged and signed

## 7. Community Engagement

### 7.1 Communication Channels
- **GitHub Discussions**: Technical discussions and proposals
- **Discord Server**: Community chat and real-time support (planned - see [LOGISTICS.md]((./LOGISTICS.md)))
- **Monthly Community Calls**: Public progress updates and Q&A (planned - see [LOGISTICS.md]((./LOGISTICS.md)))
- **Documentation Site**: Centralized documentation hub

### 7.2 Contribution Guidelines
- **VIP Process**: Technical changes through formal proposal
- **Implementation PRs**: Code contributions to specific implementations
- **Documentation**: Improvements to specs and guides
- **Testing**: Compatibility test contributions

### 7.3 Recognition
- **Contributor Recognition**: Monthly contributor highlights
- **Implementation Badges**: Recognition for maintainers
- **Conference Speaking**: Support for community speakers

## 8. Intellectual Property

### 8.1 Licensing Strategy
- **Schema Specification**: Creative Commons CC-BY-4.0
- **Reference Implementations**: MIT or Apache-2.0
- **Compatibility Tests**: MIT license for maximum adoption

### 8.2 Patent Policy
- **Defensive Patent License**: Patent grant for VCP implementations
- **Contributor Agreement**: DCO (Developer Certificate of Origin)
- **Provider Patents**: Clear guidance on patent-safe implementations

### 8.3 Trademark Management
- **VCP Mark**: "Voice Context Protocol" protected trademark
- **Usage Guidelines**: Clear guidelines for VCP branding
- **Compliance Badges**: Certification marks for compliant implementations

## 9. Foundation Transition

### 9.1 Transition Timeline
- **2025 Q4**: Current governance charter implementation
- **2026 Q2**: Foundation evaluation and selection
- **2026 Q4**: Foundation transition (if warranted by adoption)

### 9.2 Foundation Criteria
- **Adoption Threshold**: 1000+ production deployments
- **Community Size**: 50+ regular contributors
- **Industry Support**: 10+ major provider integrations

### 9.3 Foundation Options
- **CNCF**: Cloud Native Computing Foundation model
- **Linux Foundation**: Linux Foundation hosting
- **Independent Foundation**: VCP-specific foundation

## 10. Metrics and Success Criteria

### 10.1 Technical Metrics
- **Schema Compliance**: 100% compatibility across implementations
- **Test Coverage**: >95% test coverage in all implementations
- **Performance**: <5% variance in performance benchmarks
- **Security**: Zero unpatched vulnerabilities >30 days

### 10.2 Adoption Metrics
- **Implementations**: Active development in Python, Rust, TypeScript
- **Providers**: Native support from 10+ voice AI providers
- **Deployments**: 1000+ production VCP deployments
- **Community**: 100+ contributors across implementations

### 10.3 Quality Metrics
- **Bug Reports**: <10 open bugs per implementation
- **Response Time**: <48 hours for security issues
- **Documentation**: Complete API documentation for all versions
- **Migration Success**: >95% successful automated migrations

## 11. Operating Procedures

### 11.1 Meeting Schedules

⚠️ **Note**: Meeting schedules are planned but not yet active. See [LOGISTICS.md]((./LOGISTICS.md)) for current implementation status.

- **TSC**: Monthly, first Tuesday, 2pm UTC (planned)
- **Schema WG**: Bi-weekly, alternating with implementation WGs (planned)
- **Implementation WGs**: Bi-weekly, coordinated scheduling (planned)
- **Community Calls**: Monthly, last Friday, 4pm UTC (planned)

### 11.2 Decision Records
- **ADR Format**: Architecture Decision Records for all major decisions
- **Public Repository**: All decisions logged in governance repository
- **Rationale Documentation**: Clear reasoning for all technical decisions

### 11.3 Escalation Paths
1. **Technical Issues**: Implementation WG → Schema WG → TSC
2. **Community Issues**: Community moderators → TSC
3. **Security Issues**: Direct to Security Response Team
4. **Governance Issues**: Direct to TSC Chair

## 12. Amendment Process

### 12.1 Charter Changes
- **Proposal**: Written amendment proposal to TSC
- **Community Review**: 30-day community comment period
- **TSC Vote**: Requires 6/7 approval for charter changes
- **Implementation**: Changes effective immediately upon approval

### 12.2 Emergency Procedures
- **Security Emergencies**: TSC Chair can authorize immediate action
- **Critical Bugs**: Implementation WG leads can coordinate emergency releases
- **Provider Outages**: Automatic fallback to previous version mappings

---

## Conclusion

This governance charter establishes VCP as a mature, professionally-managed open standard with coordinated multi-language implementations. The framework balances implementation flexibility with specification consistency, ensuring VCP's continued evolution as the definitive voice AI interoperability protocol.

**Effective Date**: October 14, 2025
**Next Review**: April 14, 2026
**Version**: 1.0

---

*This charter is a living document, evolved through the VIP process and community feedback.*



================================================================================
📄 FILE: LOGISTICS.md
📝 TITLE: Community Logistics & Sync
📊 SIZE: 6,034 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# Community Logistics & Sync

This document outlines the planned community synchronization methods and logistics for the Voice Context Protocol (VCP) ecosystem.

## Current Status

⚠️ **Important**: The community sync methods described below are **planned but not yet active**. 

For current communication, please refer to [CONTACT-US.md]((./CONTACT-US.md)) for all active contact methods.

## Planned Community Sync Schedule

The following community events are being planned for future implementation:

### Regular Community Meetings

#### Technical Steering Committee (TSC) Meetings
- **Frequency**: First Tuesday of each month
- **Time**: 2:00 PM UTC
- **Duration**: 90 minutes
- **Participants**: TSC members, invited contributors
- **Format**: Private video conference
- **Purpose**: Strategic decisions, breaking change approvals, roadmap planning

#### Schema Working Group (SWG) Meetings  
- **Frequency**: Bi-weekly (every other Wednesday)
- **Time**: 3:00 PM UTC
- **Duration**: 60 minutes
- **Participants**: Open to all contributors
- **Format**: Public video conference
- **Purpose**: Schema evolution, VIP reviews, implementation coordination

#### Provider Integration Council (PIC) Meetings
- **Frequency**: Monthly (third Thursday)
- **Time**: 4:00 PM UTC
- **Duration**: 45 minutes
- **Participants**: Provider representatives, integration maintainers
- **Format**: Hybrid (video + async updates)
- **Purpose**: Provider onboarding, mapping updates, compliance discussions

#### Community Office Hours
- **Frequency**: Last Friday of each month
- **Time**: 4:00 PM UTC
- **Duration**: 60 minutes
- **Participants**: Open to all community members
- **Format**: Public video conference with Q&A
- **Purpose**: General questions, community feedback, announcements

### Asynchronous Communication Channels

#### GitHub Discussions
- **Purpose**: Technical discussions, proposals, community Q&A
- **Categories**: 
  - General discussion
  - VIP (VCP Improvement Proposals)
  - Show and tell
  - Q&A
- **Status**: ✅ **Active** - Available now

#### Community Discord Server (Planned)
- **Channels**: 
  - #general - General community chat
  - #technical - Technical discussions
  - #governance - Governance and process discussions
  - #announcements - Official announcements
  - #providers - Provider-specific discussions
- **Status**: 🔄 **Planned** - Not yet active

#### Mailing Lists (Planned)
- **community@voicecontext.org** - General announcements and discussions
- **technical@voicecontext.org** - Technical discussions and updates
- **governance@voicecontext.org** - Governance matters and voting
- **Status**: 🔄 **Planned** - Not yet active

### Documentation and Knowledge Sharing

#### Community Wiki (Planned)
- **Purpose**: Community-maintained documentation, tutorials, best practices
- **Platform**: GitHub Wiki or dedicated platform
- **Status**: 🔄 **Planned** - Not yet active

#### Monthly Newsletter (Planned)
- **Content**: Project updates, community highlights, upcoming events
- **Distribution**: Email and GitHub
- **Status**: 🔄 **Planned** - Not yet active

## Event Coordination

### Meeting Scheduling
- All meetings will be scheduled with consideration for global time zones
- Calendar invites will be distributed via community channels
- Recordings will be made available for asynchronous participation (where appropriate)

### Time Zone Considerations
Primary time zone: UTC
Secondary considerations: Pacific Time, Eastern Time, Central European Time

### Meeting Platforms
- **Video Conferencing**: Google Meet or Zoom (to be determined)
- **Voice Chat**: Discord (when available)
- **Text Chat**: GitHub Discussions, Discord

## Communication Protocols

### Emergency Communications
For urgent technical issues or security matters:
- Contact: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
- Subject line: "URGENT: [brief description]"
- Response time: 24 hours maximum

### Regular Updates
- **Weekly**: Project status updates via GitHub
- **Monthly**: Community newsletter (when active)
- **Quarterly**: Roadmap reviews and strategic updates

### Decision Making Process
1. **Proposal**: Submit via GitHub Discussions or formal VIP
2. **Community Review**: 2-week comment period
3. **TSC Review**: Technical and strategic evaluation
4. **Decision**: Formal approval and implementation plan

## Regional Coordination (Future)

Planned regional coordinators for:
- **Americas**: English, Spanish, Portuguese
- **Europe/Africa**: English, French, German
- **Asia-Pacific**: English, Japanese, Mandarin

*Regional coordination is not yet active but is part of the long-term community growth plan.*

## Getting Involved

While formal sync processes are being established, you can participate now by:

1. **GitHub**: Open issues, submit PRs, join discussions
2. **Email**: Reach out via [info@e.integrate.cloud](mailto:info@e.integrate.cloud)
3. **Documentation**: Help improve docs and guides
4. **Testing**: Test implementations and report issues

## Implementation Timeline

The community sync infrastructure will be implemented in phases:

### Phase 1: Foundation (Q1 2024)
- ✅ Basic GitHub infrastructure
- ✅ Contact centralization
- 🔄 Discord server setup
- 🔄 Initial TSC formation

### Phase 2: Regular Sync (Q2 2024)
- 🔄 Monthly TSC meetings
- 🔄 Bi-weekly technical calls
- 🔄 Community office hours
- 🔄 Mailing list setup

### Phase 3: Full Ecosystem (Q3-Q4 2024)
- 🔄 Regional coordination
- 🔄 Provider integration council
- 🔄 Community wiki
- 🔄 Monthly newsletter

## Updates and Changes

This document will be updated as community sync methods become active. Check the commit history for recent changes.

For questions about community logistics or to volunteer for coordination roles, please contact: [info@e.integrate.cloud](mailto:info@e.integrate.cloud)

---

**Last Updated**: January 2024
**Document Version**: 1.0.0
**Status**: Planning Phase - Not Yet Active

**Active Contact Method**: [CONTACT-US.md]((./CONTACT-US.md))



================================================================================
📄 FILE: reports/quality.md
📝 TITLE: VoiceLens Dataset Quality Assessment Report
📊 SIZE: 5,549 bytes
⏰ PROCESSED: 2025-10-14 16:34:27 UTC
================================================================================

# VoiceLens Dataset Quality Assessment Report

## Executive Summary

**Project:** VoiceAI4HVAC LocalHVAC Dataset  
**Generation Date:** October 12, 2025  
**Dataset Period:** August 14, 2025 - October 13, 2025 (60 days)  
**Total Conversations:** 1,800  
**Overall Quality Score:** 100/100 (Grade A)

## ✅ Key Achievements

### Perfect Delivery Record
- **100% Success Rate**: All 1,800 conversations successfully delivered to webhook
- **Zero Failed Deliveries**: No permanent failures or data loss
- **Efficient Processing**: ~3 minutes total delivery time with 10 RPS throughput
- **Robust Error Handling**: 4 timeouts automatically retried and resolved

### Excellent Data Quality
- **100% HVAC Terminology Coverage**: All sampled conversations contain relevant HVAC terms
- **PII Compliance**: Zero personal identifiable information detected
- **Realistic Duration Distribution**: 30-220 second range with 130s average
- **Temporal Authenticity**: Natural distribution across 60-day period

### Diverse Content Library
- **7 Distinct Scenarios**: Well-balanced mix of HVAC service interactions
- **3 Provider Coverage**: Equal distribution across Retell, Vapi, and Bland
- **Realistic Patterns**: Peak hours align with typical HVAC service demand

## 📊 Distribution Analysis

### Scenario Breakdown
| Scenario | Count | Percentage | Assessment |
|----------|-------|------------|------------|
| Scheduled Callback | 367 | 20.4% | ✅ Appropriate weight |
| Spam Filtered | 324 | 18.0% | ✅ Realistic frequency |
| Booked Service | 300 | 16.7% | ✅ High-value scenario |
| Emergency Service | 294 | 16.3% | ✅ Critical use case |
| Live Transfer | 254 | 14.1% | ✅ Common escalation |
| Out of Service Area | 166 | 9.2% | ✅ Geographic limitation |
| Quote Requested | 95 | 5.3% | ✅ Sales opportunity |

### Provider Distribution
- **Bland AI**: 640 conversations (35.6%)
- **Vapi**: 603 conversations (33.5%)  
- **Retell**: 557 conversations (30.9%)

*Assessment: Excellent balance across all three major voice AI providers*

### Temporal Patterns
- **Peak Activity**: 02:00 (96 calls) - Likely emergency scenarios
- **Business Hours**: Strong presence during 8-20:00 window
- **Weekend Coverage**: Appropriate reduced volume on Sat/Sun
- **Daily Spread**: 220-294 conversations per day

## 🔍 Quality Validation Results

### Content Realism (20/20 samples checked)
- **HVAC Terminology**: 100% coverage rate
- **Scenario Authenticity**: All scenarios contain appropriate context
- **Duration Realism**: All conversations within expected ranges
- **Professional Language**: Appropriate technical and customer service terminology

### Common HVAC Terms Detected:
- Service, technician, appointment, emergency
- AC, heating, cooling, temperature, thermostat
- Maintenance, repair, installation, warranty
- Filter, duct, furnace, HVAC

### Data Security Assessment
- **PII Compliance**: ✅ No real personal information detected
- **Synthetic Data Only**: ✅ Generated names, phones, emails
- **Safe for Testing**: ✅ Appropriate for training and development use

## 📈 Performance Metrics

### Generation Efficiency
- **Speed**: 40 conversations/second generation rate
- **Consistency**: Stable output quality throughout batch
- **Resource Usage**: Efficient memory and CPU utilization

### Delivery Performance
- **Throughput**: 9.38 conversations/second delivery rate
- **Reliability**: 100% acknowledgment rate from webhook
- **Resilience**: Automatic retry on 4 timeout scenarios
- **Monitoring**: Complete delivery logs maintained

## 🎯 Recommendations for Future Datasets

### Scenario Expansion Opportunities
1. **Add Warranty Claim Scenarios** (5% of volume)
2. **Include Seasonal Maintenance** (HVAC tune-ups, filter changes)
3. **Expand Spanish Language Support** (Currently 0%, recommend 5-10%)
4. **Commercial vs Residential Split** (Currently mixed, could categorize)

### Technical Enhancements
1. **Conversation Transcript Integration**: Add realistic turn-by-turn dialogue
2. **Customer Journey Tracking**: Link related conversations over time
3. **Geographic Distribution**: Include regional HVAC patterns
4. **Sentiment Analysis**: Add customer satisfaction scores

### Volume Scaling Considerations
- Current generation rate supports **10,000+ conversations/hour**
- Webhook can handle **10-15 RPS sustained** with current configuration
- For larger datasets, consider batching strategy or parallel webhooks

## 🔧 Technical Implementation Notes

### Successful Architecture
- **Async HTTP Delivery**: aiohttp with connection pooling
- **Rate Limiting**: Conservative 10 RPS to respect endpoint limits  
- **Progress Tracking**: Resume capability for interrupted deliveries
- **Error Handling**: Exponential backoff with jitter

### Configuration Used
```yaml
generation:
  count: 1800
  seed: 42
  time_span: 60 days
  providers: [retell, vapi, bland]

delivery:
  concurrency: 8
  rate_limit: 10.0 rps
  retries: 3
  timeout: 30s
```
## 🎉 Conclusion

The VoiceAI4HVAC dataset delivery exceeded all quality targets with perfect execution. The synthetic conversation data provides excellent coverage of HVAC service scenarios while maintaining complete PII compliance. The delivery system demonstrated robust performance with 100% success rate and efficient throughput.

**This dataset is production-ready for training, testing, and development purposes.**

---

*Report generated automatically by VoiceLens Quality Analyzer v1.0*  
*For questions or additional analysis, contact the VoiceLens team*



================================================================================
📊 DOCUMENTATION SUMMARY
================================================================================

**Total Files Processed**: 20
**Total Content Size**: 266,595 bytes (260.3 KB)
**Generated At**: 2025-10-14 16:34:27 UTC

## Files Included:

- **docs/README.md** - Voice Context Protocol (VCP) System - Complete Documentation (16,721 bytes)
- **docs/VCP_SYSTEM_OVERVIEW.md** - Voice Context Protocol (VCP) System Documentation (25,309 bytes)
- **docs/VCP_SCHEMA_SPECIFICATION.md** - VCP Schema v0.5 - Complete Specification (24,347 bytes)
- **docs/PROVIDER_INTEGRATION_GUIDE.md** - Provider Integration & Mapping Implementation Guide (27,147 bytes)
- **docs/DEPLOYMENT_OPERATIONS_GUIDE.md** - VCP System Deployment & Operations Guide (24,088 bytes)
- **README.md** - VoiceLens Scripts (13,125 bytes)
- **ASSISTABLE_AI_INTEGRATION.md** - Assistable.ai Integration with VCP v0.5 (10,299 bytes)
- **DEPLOYMENT.md** - VoiceLens Scripts Deployment Guide (16,308 bytes)
- **CONTRIBUTING.md** - Contributing to VoiceLens Scripts (3,973 bytes)
- **VCP_WORKING_GROUPS_STRUCTURE.md** - VCP Working Groups Structure & Operations (16,758 bytes)
- **USAGE.md** - VoiceLens Scripts Usage Guide (7,009 bytes)
- **VCP_GOVERNANCE_EXECUTIVE_SUMMARY.md** - VCP Governance Executive Summary & Implementation Roadmap (12,666 bytes)
- **VCP_V0.5_CHANGELOG.md** - Voice Context Protocol (VCP) v0.5 Changelog & Migration Guide (10,346 bytes)
- **README_ENVIRONMENT.md** - VoiceLens Environment Management (3,408 bytes)
- **CONTACT-US.md** - Contact Us (3,033 bytes)
- **HANDOVER_GUIDE.md** - VoiceLens Dataset Generation & Delivery Handover Guide (8,369 bytes)
- **VCP_IMPLEMENTATION_CONSISTENCY_FRAMEWORK.md** - VCP Implementation Consistency Framework (16,955 bytes)
- **VCP_GOVERNANCE_CHARTER.md** - Voice Context Protocol (VCP) Governance Charter (15,151 bytes)
- **LOGISTICS.md** - Community Logistics & Sync (6,034 bytes)
- **reports/quality.md** - VoiceLens Dataset Quality Assessment Report (5,549 bytes)

---

*This consolidated documentation provides complete context about the VoiceLens Scripts project,
including the Voice Context Protocol (VCP) system, provider integrations, deployment guides,
and operational procedures.*

**Repository**: https://github.com/prompted365/voicelens-scripts
**Documentation Directory**: docs/
**Last Updated**: 2025-10-14 16:34:27 UTC
